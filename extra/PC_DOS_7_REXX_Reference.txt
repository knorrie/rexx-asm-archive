REXX Language - Introduction
 
 
 The REstructured eXtended eXecutor language, or REXX, is an easy-to-use yet 
 powerful programming language that is an integral part of PC DOS. Its 
 simplicity makes it a good first language for beginners. For more 
 experienced users, REXX offers powerful functions, extensive mathematical 
 capabilities, and the ability to issue commands to multiple environments. 
 
 The information provided in this book describes PC DOS and the REXX 
 Language.  This book is intended for experienced programmers, particularly 
 those who have used a block-structured, high level language (for example, 
 PL/I, C, or Pascal). It assumes you are already familiar with REXX 
 programming concepts. 
 
 REXX is a programming language that combines the simplicity of a language 
 such as BASIC with the ability to write fewer lines as in a more powerful 
 language.  It is easy to learn because it uses familiar words and concepts. 
 REXX lets you do simple tasks, yet has the ability to handle complex tasks. 
 
 A REXX program is processed by an interpreter.  When a REXX program runs, 
 its language processor reads each language statement from the source file 
 and runs it, one statement at a time.  Languages that are not interpreted 
 must be compiled into machine language (in separate files) before they can 
 be run. 
 
 REXX uses a few powerful, general-purpose programming functions and common 
 arithmetical abilities, as well as PC DOS commands, within a simple 
 framework. Existing batch files can be converted to REXX procedures, with 
 more power and function. 
 
 It is recommended that REXX files created in PC DOS have a file name 
 extension of .BAT. REXX files that have a .BAT file name extension can be 
 executed by simply entering the REXX file name at the command line (for 
 example, C:\> rexxfn). You can use REXX files that have different file name 
 extensions, including those created in other environments (such as OS/2 
 REXX files, which have a file name extension of .CMD) in the PC DOS 
 environment. To use these files in PC DOS, you preface the REXX file name 
 with rexx and include the file name extension (for example, C:\> rexx 
 rexxfn.cmd). 
 
 Notes: 
   
   Regardless of the environment in which a REXX file is created, all REXX 
   files must start with a comment line (/*...*/). 
   
   For PC DOS, the .RX file name extension is reserved for utilities; see 
   "External Functions" for more information. 
 
 Double-click on What Goes into a REXX Program to continue.  



What Goes into a REXX Program
 
 
 This section describes the type of information and the terms that are used 
 in a REXX program.  Some of the information that is discussed includes: 
   
   o Comments 
   o Keyword Instructions 
   o Hexadecimal Strings 
   o Binary Strings 
   o Literal Strings 
   o Numbers 
   o Special Characters 
   o Implied Semicolons 
   o Continuations 
   o Expressions and Operators 
   o Assignments and Symbols 
    



Comments
 
 
 When you write a program, you will want to read it later (for example, 
 before improving it).  Other users of your program will also want to read 
 it to know what the program is for, what kind of input it can handle, what 
 kind of output it produces, and so forth.  You may also want to write 
 remarks about individual instructions.  All these things, words that are to 
 be read by people but not interpreted by REXX, are called "comments." 
 
 To indicate comments, use /* to mark the start of a comment and */ to mark 
 the end of a comment. 
 
 The /* causes REXX to stop interpreting the program. Interpreting starts 
 again only after a */ is found, which may be a few words or several lines 
 later.  For example: 
 
 /* This is a comment. */
 
 say ...  /* This is a comment on the same line as the instruction */
 
 /* Comments may
    occupy more
    than one line. */
 
 Click on First-line Comments to continue.  



First-line Comments
 
 
 The first line of a REXX program must start with a comment.  PC DOS can be 
 programmed with its built-in Batch language and in REXX language.  Both 
 Batch language and REXX language can use the file name extension BAT.  Each 
 type requires its own special processing, so PC DOS checks the first line 
 of the program. If it finds a REXX-style comment, the program is processed 
 as REXX. Therefore, to recognize that your program is written in REXX, the 
 first line of the file must be or begin a comment. For example: 
 
 /* this is a REXX program.  */
 
 Also, the first-line comment must begin in column 1.  It is sufficient to 
 use /* */, but a better use for the space is to give a brief description of 
 your program.  You can also do it this way. 
 
 /*************************************
 *  HELLO.BAT written by J. Smith     *
 *       Jan 30, 1995                 *
 * A program to greet a user by name. *
 *************************************/
 
 



Keyword Instructions
 
 
 Words such as SAY, PULL, and IF are part of the REXX language called 
 "instructions."  The words themselves are referred to as "keywords."  You 
 will notice that they are usually verbs.  They are the directions that tell 
 REXX what to do with information at a certain point in the program. 
  
  SAY displays information on the screen. 
  PULL accepts and stores information from the user. 
  IF tests whether an expression is true, then performs a specified action. 
  
  
 
 When you list these instructions in the order you want REXX to execute 
 them, you have created a program.  



Clauses
 
 
 A REXX program is made up of "clauses"; that is, complete instructions, 
 including the information it works on and any options that may be used.  
 The clauses are composed of: 
  
  o Zero or more blanks (which are ignored). 
  o A sequence of "tokens."  (A token is a unit of low-level syntax from 
    which clauses are built). 
  o Zero or more blanks (again ignored). 
  o A semicolon (;) delimiter that may be implied by line-end, certain 
    keywords, or the colon (;). 
  
 
 REXX reads each clause and processes it before going on to the next.  That 
 is why REXX is an "interpreted" language. The examples and sample programs 
 in this book follow the convention of one clause to a line, except where 
 noted.  



Labels
 
 
 A clause that consists of a single symbol followed by a colon is a "label." 
 The colon in this context implies a semicolon (clause 
 separator), so no semicolon is required. Labels identify the targets of 
 CALL instructions, SIGNAL instructions, and internal function calls. More 
 than one label may precede any instruction. Labels are treated as null 
 clauses and can be traced selectively to aid debugging. 
 
 Any number of successive clauses may be labels. This permits multiple 
 labels before other clauses. Duplicate labels are permitted, but control 
 passes only to the first of any duplicates in a program. The duplicate 
 labels occurring later can be traced but cannot be used as a target of a 
 CALL, SIGNAL, or function invocation.  



Hexadecimal Strings
 
 
 A "hexadecimal string" is a literal string, expressed using a hexadecimal 
 notation of its encoding. It is any sequence of zero or more hexadecimal 
 digits (0-9, a-f, A-F), grouped in pairs. A single leading 0 is assumed, if 
 necessary, at the front of the string to make an even number of hexadecimal 
 digits. The groups of digits are optionally separated by one or more 
 blanks, and the whole sequence is delimited by single or double quotation 
 marks, and immediately followed by the symbol X or x. (Neither x nor X can 
 be part of a longer symbol.) The blanks, which may be present only at byte 
 boundaries (and not at the beginning or end of the string), are to aid 
 readability.  The language processor ignores them. A hexadecimal string is 
 a literal string formed by packing the hexadecimal digits given. Packing 
 the hexadecimal digits removes blanks and converts each pair of hexadecimal 
 digits into its equivalent character, for example:  '41'X to A. 
 
 Hexadecimal strings let you include characters in a program even if you 
 cannot directly enter the characters themselves. These are valid 
 hexadecimal strings: 
 
 'ABCD'x
 "1d ec f8"X
 "1 d8"x
 
 Note: A hexadecimal string is not a representation of a number. Rather, it 
 is an escape mechanism that lets a user describe a character in terms of 
 its encoding (and, therefore, is machine-dependent). In ASCII, '20'X is the 
 encoding for a blank. In every case, a string of the form '.....'x is 
 simply an alternative to a straightforward string. In ASCII '41'x and 'A' 
 are identical, as are '20'x and a blank, and must be treated identically. 
 
 Implementation maximum: The packed length of a hexadecimal string (the 
 string with blanks removed) cannot exceed 250 bytes.  



Binary Strings
 
 
 A "binary string" is a literal string, expressed using a binary 
 representation of its encoding. It is any sequence of zero or more binary 
 digits (0 or 1) in groups of 8 (bytes) or 4 (nibbles). The first group may 
 have fewer than four digits; in this case, up to three 0 digits are assumed 
 to the left of the first digit, making a total of four digits. The groups 
 of digits are optionally separated by one or more blanks, and the whole 
 sequence is delimited by matching single or double quotation marks and 
 immediately followed by the symbol b or B. (Neither b nor B can be part of 
 a longer symbol.) The blanks, which may be present only at byte or nibble 
 boundaries (and not at the beginning or end of the string), are to aid 
 readability. The language processor ignores them. 
 
 Binary strings allow you to specify characters explicitly, bit by bit. A 
 binary string is a literal string formed by packing the binary digits 
 given. If the number of binary digits is not a multiple of eight, leading 
 zeros are added on the left to make a multiple of eight before packing. 
 Binary strings allow you to specify characters explicitly, bit by bit. 
 
 These are valid binary strings: 
 
 '11110000'b        /* == 'f0'x                  */
 "101 1101"b        /* == '5d'x                  */
 '1'b               /* == '00000001'b and '01'x  */
 '10000 10101010'b  /* == '0001 0000 1010 1010'b */
 ''b                /* == ''                     */
 
 Implementation maximum: The packed length of a binary-literal string may 
 not exceed 100 bytes.  



Literal Strings
 
 
 When REXX finds a quotation mark (either " or '), it stops processing and 
 looks ahead for the matching quotation mark.  The string of characters 
 inside the matching quotation marks is used as it is and is called a 
 "literal string."  Examples of literal strings are: 
 
   'Hello'
   "Final result:"
 
 If you need to use quotation marks within a literal string, use quotation 
 marks of the other type to delimit the string.  For example: 
 
   "Don't panic"
   'He said, "Bother"'
 
 There is another way.  Within a literal string, a pair of quotation marks 
 (the same type that delimits the string) is interpreted as one of that 
 type.  For example: 
 
   'Don''t panic'             /* same as "Don't panic" */
   "He said, ""Bother"""    /* same as 'He said, "Bother"' */
 
 Implementation Maximum:  Literal strings cannot exceed 65535 bytes 
 (64K-1).  



Uppercase Translation
 
 
 When a clause is processed, any letters that are not in quotation marks are 
 translated to uppercase.  For example, the letters a, b, c, ... z are 
 changed to A, B, C, ... Z. 
 
 REXX also ignores some of the spaces that you may have written into your 
 program, keeping only one space between words.  HELLO1.BAT shows an example 
 using quotation marks to get more than one space between words. 
 
 HELLO1.BAT: 
 
 /* Example: cases and spaces */
 say  Hello!     What     is     your     name?
 
 say "Hello!     What     is     your     name?"
 
 say Hello!"    "stranger!
 
 The following is displayed on the screen, when you run the HELLO1 program. 
 
 [C:\] hello1
 HELLO! WHAT IS YOUR NAME?
 Hello!     What     is     your     name?"
 HELLO!    STRANGER!
 [C:\]
 
 Note: The PULL instruction always converts keyboard input to uppercase, 
 which allows the user to type any combination of uppercase and lowercase 
 letters.  (To retain input in the case entered, you can use PARSE PULL.)  



Numbers
 
 
 A "number" is a character string consisting of one or more decimal digits, 
 with an optional prefix of a plus or minus sign, and optionally including a 
 single period (.) that represents a decimal point. A number can also have a 
 power of 10 suffixed in conventional exponential notation: an E (uppercase 
 or lowercase), followed optionally by a plus or minus sign, then followed 
 by one or more decimal digits defining the power of 10. Whenever a 
 character string is used as a number, rounding may occur to a precision 
 specified by the NUMERIC DIGITS instruction (default nine digits). 
 
 Numbers can have leading blanks (before and after the sign, if any) and can 
 have trailing blanks. Blanks may not be embedded among the digits of a 
 number or in the exponential part. Note that a symbol or a literal string 
 may be a number. A number cannot be the name of a variable. 
 
 These are valid numbers: 
 
 12
 '-17.9'
 127.0650
 73e+128
 ' + 7.9E5 '
 
 A "whole number" is a number that is zero after the decimal point, or has 
 no decimal point and that the language processor would not usually express 
 in exponential notation. That is, it has no more digits before the decimal 
 point than the current setting of NUMERIC DIGITS (the default is 9).  



Special Characters
 
 
 The following characters, together with the individual characters from the 
 operators, have special significance when found outside of literal strings: 
 
 ,   ;   :   )   (
 
 These characters constitute the set of "special characters." They all act 
 as token delimiters, and blanks adjacent to any of these are removed. There 
 is an exception: a blank adjacent to the outside of a parenthesis is 
 deleted only if it is also adjacent to another special character (unless 
 the character is a parenthesis and the blank is outside it, too). For 
 example, the language processor does not remove the blank in A (Z). This is 
 a concatenation that is not equivalent to A(Z), a function call. The 
 language processor does remove the blanks in (A) + (Z) because this is 
 equivalent to (A)+(Z).  



Implied Semicolons
 
 
 The last element in a clause is the semicolon delimiter.  The language 
 processor implies the semicolon: at a line-end, after certain keywords, and 
 after a colon if it follows a single symbol. This means that you need to 
 include semicolons only when there is more than one clause on a line or to 
 end an instruction whose last character is a comma. 
 
 A line-end usually marks the end of a clause and, thus, REXX implies a 
 semicolon at most end of lines. However, there are the following 
 exceptions: 
   
   o The line ends in the middle of a comment. The clause continues on 
     to the next line. 
   o The last token was the continuation character (a comma) and the 
     line does not end in the middle of a comment. (Note that a comment 
     is not a token.) 
   
 
 REXX automatically implies semicolons after colons (when following a single 
 symbol, a label) and after certain keywords when they are in the correct 
 context.  The keywords that have this effect are:  ELSE, OTHERWISE, and 
 THEN.  These special cases reduce typographical errors significantly. 
 
 Note: The two characters forming the comment delimiters, /* and */, must 
 not be split by a line-end (that is, / and * should not appear on different 
 lines) because they could not then be recognized correctly; an implied 
 semicolon would be added.  



Continuations
 
 
 One way to continue a clause onto the next line is to use the comma, which 
 is referred to as the "continuation character." The comma is functionally 
 replaced by a blank, and, thus, no semicolon is implied. One or more 
 comments can follow the continuation character before the end of the line. 
 
 The following example shows how to use the continuation character to 
 continue a clause. 
 
 say 'You can use a comma',
     'to continue this clause.'
 
 This displays: 
 
 You can use a comma to continue this clause.
 
 



Expressions and Operators
 
 
 Expressions in REXX are a general mechanism for combining one or more 
 pieces of data in various ways to produce a result, usually different from 
 the original data. 
 
 Double-click on one of the following for more information. 
   
   o Expressions 
   o Operators 
    



Expressions
 
 
 An "expression" consists of one or more "terms" (literal strings, symbols, 
 function calls, or subexpressions) interspersed with zero or more operators 
 that denote operations to be carried out on terms. A "subexpression" is a 
 term in an expression bracketed within a left and a right parenthesis. 
 
 Terms include: 
 
 o Literal Strings (delimited by quotation marks), which are constants 
 o Symbols (no quotation marks), which are translated to uppercase. A 
   symbol that does not begin with a digit or a period may be the name of 
   a variable; in this case the value of that variable is used. Otherwise 
   a symbol is treated as a constant string. A symbol can also be 
   "compound." 
 o Function calls (see "Functions"), which are of the form: 
   
                            ÚÄ,ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                            ³
   >>ÄÄÂÄsymbol(ÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÁÄÄ)ÄÄ><
       ÀÄliteral_string(ÄÙ    ÀÄexpressionÄÙ
   
   
 Evaluation of an expression is left to right, modified by parentheses and 
 by operator precedence in the usual algebraic manner (see "Parentheses and 
 Operator Precedence"). Expressions are wholly evaluated, unless an error 
 occurs during evaluation. 
 
 All data is in the form of "typeless" character strings (typeless because 
 it is not-as in some other languages-of a particular declared type, such as 
 Binary, Hexadecimal, Array, and so forth).  Consequently, the result of 
 evaluating any expression is itself a character string. Terms and results 
 (except arithmetic and logical expressions) may be the "null string" (a 
 string of length 0). Note that REXX imposes no restriction on the maximum 
 length of results.  



Operators
 
 
 An "operator" is a representation of an operation, such as addition, to be 
 carried out on one or two terms. The following panels describe how each 
 operator (except for the prefix operators) acts on two terms, which may be 
 symbols, strings, function calls, intermediate results, or subexpressions. 
 Each prefix operator acts on the term or subexpression that follows it. 
 Blanks (and comments) adjacent to operator characters have no effect on the 
 operator; thus, operators constructed from more than one character can have 
 embedded blanks and comments. In addition, one or more blanks, where they 
 occur in expressions but are not adjacent to another operator, also act as 
 an operator. There are four types of operators: 
   
   o String Concatenation 
   o Arithmetic 
   o Comparison 
   o Logical (Boolean) 
   



String Concatenation
 
 
 The concatenation operators combine two strings to form one string by 
 appending the second string to the right-hand end of the first string. The 
 concatenation may occur with or without an intervening blank. The 
 concatenation operators are: 
   
   (blank)     Concatenate terms with one blank in between 
   ||          Concatenate without an intervening blank 
   (abuttal)   Concatenate without an intervening blank 
   
 
 You can force concatenation without a blank by using the || operator. 
 
 The abuttal operator is assumed between two terms that are not separated by 
 another operator. This can occur when two terms are syntactically distinct, 
 such as a literal string and a symbol, or when they are separated only by a 
 comment. 
 
 Examples: 
 
 An example of syntactically distinct terms is: if Fred has the value 
 37.4, then Fred'%' evaluates to 37.4%. 
 
 If the variable PETER has the value 1, then (Fred)(Peter) evaluates to 
 37.41. 
 
 In the case of: 
 
         Fred/* The NOT operator precedes Peter. */ªPeter
 
 there is no abuttal operator implied, and the expression is not valid.  
 However, 
 
         (Fred)/* The NOT operator precedes Peter. */(ªPeter)
 
 results in an abuttal, and evaluates to 37.40.  



Arithmetic
 
 
 You can combine character strings that are valid numbers using the 
 arithmetic operators: 
 
 +           Add 
 -           Subtract 
 *           Multiply 
 /           Divide 
 %           Integer divide (divide and return the integer part 
             of the result) 
 //          Remainder (divide and return the remainder-not 
             modulo, because the result may be negative) 
 **          Power (raise a number to a whole-number power) 
 Prefix -    Same as the subtraction:  0 - number 
 Prefix +    Same as the addition:  0 + number 
 
 
 Note that if an arithmetic result is shown in exponential notation, it is 
 likely that rounding has occurred.  



Comparison
 
 
 The comparison operators compare two terms and return the value 1 if the 
 result of the comparison is true, or 0 otherwise. 
 
 The strict comparison operators all have one of the characters defining the 
 operator doubled. The ==, \==, and ª== operators test for an exact match 
 between two strings.  The two strings must be identical, character by 
 character, and of the same length to be considered strictly equal. 
 Similarly, the strict comparison operators such as >> or << carry out a 
 simple character-by-character comparison, with no padding of either of the 
 strings being compared.  The comparison of the two strings is from left to 
 right. If one string is shorter than and is a leading substring of another, 
 then it is smaller than (less than) the other. The strict comparison 
 operators also do not attempt to perform a numeric comparison on the two 
 operands. 
 
 For all the other comparison operators, if both terms involved are numeric, 
 a numeric comparison is done. Otherwise, both terms are treated as 
 character strings (leading and trailing blanks are ignored, and then the 
 shorter string is padded with blanks on the right). 
 
 Character comparison and strict comparison operations are both 
 case-sensitive, and for both, the exact collating order may depend on the 
 character set used for the implementation. For example, in an EBCDIC 
 environment, lowercase alphabetics precede uppercase, and the digits 0-9 
 are higher than all alphabetics. In an ASCII environment, the digits are 
 lower than the alphabetics, and lowercase alphabetics are higher than 
 uppercase alphabetics. 
 
 The comparison operators and operations are: 
 
 =           True if the terms are equal (numerically or when 
             padded, and so forth) 
 \=,ª=       True if the terms are not equal (inverse of =) 
 >           Greater than 
 <           Less than 
 ><          Greater than or less than (same as not equal) 
 <>          Greater than or less than (same as not equal) 
 >=          Greater than or equal to 
 \<, ª<      Not less than 
 <=          Less than or equal to 
 \>, ª>      Not greater than 
 ==          True if terms are strictly equal (identical) 
 \==,ª==     True if the terms are NOT strictly equal (inverse 
             of ==) 
 >>          Strictly greater than 
 <<          Strictly less than 
 >>=         Strictly greater than or equal to 
 \<<, ª<<    Strictly NOT less than 
 <<=         Strictly less than or equal to 
 \>>, ª>>    Strictly NOT greater than 
 
 
 Note: Throughout the language, the not character, ª, is synonymous with the 
 backslash (\).  You can use the two characters interchangeably, according 
 to availability and personal preference. The backslash can appear in the 
 following operators: \ (prefix not), \=, \==, \<, \>, \<<, and \>>.  



Logical (Boolean)
 
 
 A character string is taken to have the value false if it is 0, and true if 
 it is 1. The logical operators take one or two such values (values other 
 than 0 or 1 are not allowed) and return 0 or 1 as appropriate: 
 
 &           AND - Returns 1 if both terms are true. 
 |           Inclusive OR - Returns 1 if either term is true. 
 &&          Exclusive OR - Returns 1 if either (but not both) 
             is true. 
 Prefix \,ª  Logical NOT - Negates; 1 becomes 0, and 0 becomes 
             1. 
 



Parentheses and Operator Precedence
 
 
 Expression evaluation is from left to right; parentheses and operator 
 precedence modify this: 
   
   o When parentheses are encountered (other than those that identify 
     function calls) the entire subexpression between the parentheses is 
     evaluated immediately when the term is required. 
   o When the sequence: 
     
     term1 operator1 term2 operator2 term3
     
     is encountered, and operator2 has a higher precedence than 
     operator1, the subexpression (term2 operator2 term3) is evaluated 
     first. The same rule is applied repeatedly as necessary. 
     
     Note, however, that individual terms are evaluated from left to 
     right in the expression (that is, as soon as they are encountered). 
     The precedence rules affect only the order of operations. 
   
 
 For example, * (multiply) has a higher priority than + (add), so 3+2*5 
 evaluates to 13 (rather than the 25 that would result if strict left to 
 right evaluation occurred). To force the addition to occur before the 
 multiplication, you could rewrite the expression as (3+2)*5. Adding the 
 parentheses makes the first three tokens a subexpression. Similarly, the 
 expression -3**2 evaluates to 9 (instead of -9) because the prefix minus 
 operator has a higher priority than the power operator. 
 
 The order of precedence of the operators is (highest at the top): 
 
 +  -  ª  \            (prefix operators) 
 **                    (power) 
 *  /  %  //           (multiply and divide) 
 +  -                  (add and subtract) 
 (blank) || (abuttal)  (concatenation with or without 
                       blank) 
 =   >   <             (comparison operators) 
 ==  >>  <<              
 \=  ª=                  
 ><  <>                  
 \>  ª>                  
 \<  ª<                  
 \==  ª==                
 \>>  ª>>                
 \<<  ª<<                
 >=  >>=                 
 <=  <<=                 
 &                     (and) 
 |  &&                 (or, exclusive or) 
 
 
 Examples: 
 
 Suppose the symbol A is a variable whose value is 3, DAY is a variable 
 whose value is Monday, and other variables are uninitialized. Then: 
 
 A+5                  ->    '8'
 A-4*2                ->    '-5'
 A/2                  ->    '1.5'
 0.5**2               ->    '0.25'
 (A+1)>7              ->    '0'         /* that is, False */
 ' '=''               ->    '1'         /* that is, True  */
 ' '==''              ->    '0'         /* that is, False */
 ' 'ª==''             ->    '1'         /* that is, True  */
 (A+1)*3=12           ->    '1'         /* that is, True  */
 '077'>'11'           ->    '1'         /* that is, True  */
 '077' >> '11'        ->    '0'         /* that is, False */
 'abc' >> 'ab'        ->    '1'         /* that is, True  */
 'abc' << 'abd'       ->    '1'         /* that is, True  */
 'ab ' << 'abd'       ->    '1'         /* that is, True  */
 Today is Day         ->    'TODAY IS Monday'
 'If it is' day       ->    'If it is Monday'
 Substr(Day,2,3)      ->    'ond'    /* Substr is a function */
 '!'xxx'!'            ->    '!XXX!'
 
 Note: The REXX order of precedence usually causes no difficulty because it 
 is the same as in conventional algebra and other computer languages. There 
 are two differences from common notations: 
   
   o The prefix minus operator always has a higher priority than the 
     power operator. 
   o Power operators (like other operators) are evaluated left-to-right. 
   
 
 For example: 
 
 -3**2     ==  9  /* not -9  */
 -(2+1)**2 ==  9  /* not -9  */
 2**2**3   == 64  /* not 256 */
 
 



Assignments and Symbols
 
 
 A "variable" is an object whose value can change during the running of a 
 REXX program. The process of changing the value of a variable is called 
 "assigning" a new value to it. The value of a variable is a single 
 character string, of any length, that may contain any characters. 
 
 You can assign a new value to a variable with the ARG, PARSE, or PULL 
 instructions, but the most common way of changing the value of a variable 
 is the assignment instruction itself. Any clause of the form: 
 
 symbol=expression; 
 
 is taken to be an assignment. The result of expression becomes the new 
 value of the variable named by the symbol to the left of the equal sign. 
 
 Example: 
 
 /* Next line gives FRED the value "Frederic" */
 Fred='Frederic'
 
 The symbol naming the variable cannot begin with a digit (0-9) or a period. 
 (Without this restriction on the first character of a variable name, you 
 could redefine a number; for example 3=4; would give a variable called 3 
 the value 4) 
 
 You can use a symbol in an expression even if you have not assigned it a 
 value, because a symbol has a defined value at all times. A variable you 
 have not assigned a value is "uninitialized."  Its value is the characters 
 of the symbol itself, translated to uppercase (that is, lowercase a-z to 
 uppercase A-Z). However, if it is a compound symbol its value is the 
 derived name of the symbol. 
 
 Example: 
 
 /* If Freda has not yet been assigned a value,   */
 /* then next line gives FRED the value "FREDA"   */
 Fred=Freda
 
 The meaning of a symbol in REXX varies according to its context. As a term 
 in an expression (rather than a keyword of some kind, for example), a 
 symbol belongs to one of four groups: constant symbols, simple symbols, 
 compound symbols, and stems. Constant symbols cannot be assigned new 
 values. You can use simple symbols for variables where the name corresponds 
 to a single value. You can use compound symbols and stems for more complex 
 collections of variables, such as arrays and lists.  



Constant Symbols
 
 
 A "constant symbol" starts with a digit (0-9) or a period. 
 
 You cannot change the value of a constant symbol.  It is simply the string 
 consisting of the characters of the symbol (that is, with any lowercase 
 alphabetic characters translated to uppercase). 
 
 These are constant symbols: 
 
 77
 827.53
 .12345
 12e5       /* Same as 12E5 */
 3D
 17E-3
 
 



Simple Symbols
 
 
 A "simple symbol" does not contain any periods and does not start with a 
 digit (0-9). 
 
 By default, its value is the characters of the symbol (that is, translated 
 to uppercase). If the symbol has been assigned a value, it names a variable 
 and its value is the value of that variable. 
 
 These are simple symbols: 
 
 FRED
 Whatagoodidea?    /* Same as WHATAGOODIDEA? */
 ?12
 
 



Compound Symbols
 
 
 A "compound symbol" permits the substitution of variables within its name 
 when you refer to it. A compound symbol contains at least one period and at 
 least two other characters. It cannot start with a digit or a period, and 
 if there is only one period in the compound symbol, it cannot be the last 
 character. 
 
 The name begins with a "stem" (that part of the symbol up to and including 
 the first period). This is followed by a "tail," parts of the name 
 (delimited by periods) that are constant symbols, simple symbols, or null. 
 The "derived name" of a compound symbol is the stem of the symbol, in 
 uppercase, followed by the tail, in which all simple symbols have been 
 replaced with their values. A tail itself can be comprised of the 
 characters A-Z, a-z, 0-9, and the value of a tail can be any character 
 string, including the null string and strings containing blanks. For 
 example: 
 
 taila='* ('
 tailb=''
 stem.taila=99
 stem.tailb=stem.taila
 say stem.tailb        /* Displays: 99                 */
 /* But the following instruction would cause an error */
 /*         say stem.* (                               */
 
 You cannot use constant symbols with embedded signs (for example, 
 12.3E+5) after a stem; in this case, the whole symbol would not be a valid 
 symbol. 
 
 These are compound symbols: 
 
 FRED.3
 Array.I.J
 AMESSY..One.2.
 
 Before the symbol is used (that is, at the time of reference), the language 
 processor substitutes the values of any simple symbols in the tail (I, J, 
 and One in the examples), thus generating a new, derived name. This derived 
 name is then used just like a simple symbol. That is, its value is by 
 default the derived name, or (if it has been used as the target of an 
 assignment) its value is the value of the variable named by the derived 
 name. 
 
 The substitution into the symbol that takes place permits arbitrary 
 indexing (subscripting) of collections of variables that have a common 
 stem. Note that the values substituted can contain any characters 
 (including periods and blanks). Substitution is done only one time. 
 
 To summarize: the derived name of a compound variable that is referred to 
 by the symbol 
 
 s0.s1.s2. --- .sn
 
 is given by 
 
 d0.v1.v2. --- .vn
 
 where d0 is the uppercase form of the symbol s0, and v1 to vn are the 
 values of the constant or simple symbols s1 through sn. Any of the symbols 
 s1-sn can be null.  The values v1-vn can also be null and can contain any 
 characters (in particular, lowercase characters are not translated to 
 uppercase, blanks are not removed, and periods have no special 
 significance). 
 
 Some examples follow in the form of a small extract from a REXX program: 
 
 a=3       /* assigns '3' to the variable A    */
 z=4                 /*   '4'      to Z        */
 c='Fred'            /*   'Fred'   to C        */
 a.z='Fred'          /*   'Fred'   to A.4      */
 a.fred=5            /*   '5'      to A.FRED   */
 a.c='Bill'          /*   'Bill'   to A.Fred   */
 c.c=a.fred          /*   '5'      to C.Fred   */
 y.a.z='Annie'       /*   'Annie'  to Y.3.4    */
 
 say  a  z  c  a.a  a.z  a.c  c.a  a.fred y.a.4
 /* displays the string:                     */
 /*    "3 4 Fred A.3 Fred Bill C.3 5 Annie"  */
 
 You can use compound symbols to set up arrays and lists of variables in 
 which the subscript is not necessarily numeric, thus offering great scope 
 for the creative programmer. A useful application is to set up an array in 
 which the subscripts are taken from the value of one or more variables, 
 effecting a form of associative memory (content addressable).  



To get Started Using REXX
 
 
 All you need to get started using REXX is: 
  
  o A Personal Computer with PC DOS 7 installed on it. 
  
  o Experience using a text editor. 
  
 
 Where to go for more information: 
 
 The information provided here is a reference of all REXX keyword 
 instructions, functions, and error messages. For detailed information on 
 what REXX is, and how to use it, see the "PC DOS 7 REXX User's Guide and 
 Reference".  



How to Read the Syntax Diagrams
 
 
 Throughout this chapter, REXX syntax is described using the structure 
 defined below. 
 
 o Read the syntax diagrams from left to right, from top to bottom, 
   following the path of the line. 
   
   >>ÄÄ symbol indicates the beginning of a statement. 
   
   ÄÄ> symbol indicates that the statement syntax is continued on the next 
   line. 
   
   >ÄÄ symbol indicates that a statement is continued from the previous 
   line. 
   
   ÄÄ>< symbol indicates the end of a statement. 
   
   Diagrams of syntactical units other than complete statements start with 
   the >ÄÄ symbol and end with the ÄÄ> symbol. 
 
 o Required items appear on the horizontal line (the main path). 
   
   >>ÄÄSTATEMENTÄÄrequired_itemÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
   
   
 
 o Optional items appear below the main path. 
   
   >>ÄÄSTATEMENTÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
                  ÀÄoptional_itemÄÙ
   
   
 
 o If you can choose from two or more items, they appear vertically, in a 
   stack. 
   
   If you must choose one of the items, one item of the stack appears on 
   the main path. 
   
   >>ÄÄSTATEMENTÄÄÂÄrequired_choice1ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
                  ÀÄrequired_choice2ÄÙ
   
   
   
   If choosing one of the items is optional, the entire stack appears 
   below the main path. 
   
   >>ÄÄSTATEMENTÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
                  ÃÄoptional_choice1Ä´
                  ÀÄoptional_choice2ÄÙ
   
   
 
 o If one of the items is the default, it appears above the main path and 
   the remaining choices are shown below. 
   
                  ÚÄdefault_choiceÄÄ¿
   >>ÄÄSTATEMENTÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
                  ÃÄoptional_choiceÄ´
                  ÀÄoptional_choiceÄÙ
   
   
 
 o An arrow returning to the left above the main line indicates an item 
   that can be repeated. 
   
                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                   ³
   >>ÄÄSTATEMENTÄÄÄÄrepeatable_itemÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
   
   A repeat arrow above a stack indicates that you can repeat the items in 
   the stack. 
 
 o A set of vertical bars around an item indicates that the item is a 
   "fragment," a part of the syntax diagram that appears in greater detail 
   below the main diagram. 
   
   >>ÄÄSTATEMENTÄÄ´ fragment ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
   
   FRAGMENT:
   ÃÄÄexpansion_provides_greater_detailÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
   
   
 
 o Keywords appear in uppercase (for example, PARM1). They must be spelled 
   exactly as shown. Variables appear in all lowercase letters (for 
   example, parmx). They represent user-supplied names or values. 
 
 o If punctuation marks, parentheses, arithmetic operators, or such 
   symbols are shown, you must enter them as part of the syntax. 
 
 
 The following example shows how the syntax is described: 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³           ÚÄ,ÄÄÄÄÄÄ¿                                                  ³
 ³                   ³                                                  ³
 ³ >>ÄÄMAX(ÄÄÄÄnumberÄÁÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 



Keyword Instructions
 
 
 A "keyword instruction" is one or more clauses, the first of which starts 
 with a keyword that identifies the instruction.  Some keyword instructions 
 affect the flow of control, while others provide services to the 
 programmer.  Some keyword instructions, like DO, can include nested 
 instructions. See Quick Reference of REXX Keyword Instructions for a 
 summary of available keyword instructions. 
 
 In the syntax diagrams on the following panels, symbols (words) in capitals 
 denote keywords or subkeywords; other words (such as expression) denote a 
 collection of tokens as defined previously. Note, however, that the 
 keywords and subkeywords are not case dependent; the symbols if, If, and iF 
 all have the same effect. Note also that you can usually omit most of the 
 clause delimiters (;) shown because they are implied by the end of a line. 
 
 A keyword instruction is recognized only if its keyword is the first token 
 in a clause, and if the second token does not start with an = character. 
 
 Blanks adjacent to keywords have no effect other than to separate the 
 keyword from the subsequent token. One or more blanks following VALUE are 
 required to separate the expression from the subkeyword in the following 
 example: 
 
   ADDRESS VALUE expression
 
 



Quick Reference of REXX Keyword Instructions
 
 
 The following table is a summary of REXX keyword instructions. 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³          REXX Instructions                                    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ INSTRUCTION   ³ ACTION                                        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ADDRESS       ³ Temporarily or permanently changes the desti- ³
 ³               ³ nation of commands.  Commands are strings     ³
 ³               ³ sent to an external environment.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ARG           ³ Retrieves the argument strings provided to a  ³
 ³               ³ program or internal routine and assigns them  ³
 ³               ³ to variables.                                 ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CALL          ³ Calls a routine, or controls the trapping of  ³
 ³               ³ certain conditions.                           ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DO            ³ Groups instructions together and optionally   ³
 ³               ³ processes them repetitively.                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DROP          ³ Restores variables to their original unini-   ³
 ³               ³ tialized state.                               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ EXIT          ³ Leaves a program unconditionally.             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ IF            ³ Conditionally processes an instruction or     ³
 ³               ³ group of instructions, depending on the eval- ³
 ³               ³ uation of an expression.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ INTERPRET     ³ Processes instructions that have been built   ³
 ³               ³ dynamically by evaluation of an expression.   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ITERATE       ³ Alters the flow within a repetitive DO loop   ³
 ³               ³ (that is, any DO construct other than that    ³
 ³               ³ with a simple DO).                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ LEAVE         ³ Causes an immediate exit from one or more     ³
 ³               ³ repetitive DO loops (that is, any DO con-     ³
 ³               ³ struct other than a simple DO).               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ NOP           ³ A dummy instruction that has no effect, NOP   ³
 ³               ³ can be useful as the target of a THEN or ELSE ³
 ³               ³ clause.                                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ NUMERIC       ³ Changes the way in which a program carries    ³
 ³               ³ out arithmetic operations.                    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ PARSE         ³ Assigns data (from various sources) to one or ³
 ³               ³ more variables according to the rules of      ³
 ³               ³ parsing.                                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ PROCEDURE     ³ Within an internal routine (subroutine or     ³
 ³               ³ function), protects variables by making them  ³
 ³               ³ unknown to the instructions that follow it.   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ PULL          ³ Reads a string from the head of the internal  ³
 ³               ³ data queue.  That is, it is added LIFO        ³
 ³               ³ (Last In, First Out).                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ PUSH          ³ Stacks the string resulting from the evalu-   ³
 ³               ³ ation of an expression onto the internal data ³
 ³               ³ queue.  That is, it is added LIFO (Last In,   ³
 ³               ³ First Out.                                    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ QUEUE         ³ Appends the string resulting from an          ³
 ³               ³ expression to the tail of the internal data   ³
 ³               ³ queue.  That is, it is added FIFO (First In,  ³
 ³               ³ First Out).                                   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ RETURN        ³ Returns control (and possibly a result) from  ³
 ³               ³ a REXX program or internal routine to the     ³
 ³               ³ point of its invocation.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ SAY           ³ Writes a line to the output stream.           ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ SELECT        ³ Conditionally calls one of several alterna-   ³
 ³               ³ tive instructions.                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ SIGNAL        ³ Causes an unusual change in the flow of       ³
 ³               ³ control, or controls the trapping of certain  ³
 ³               ³ conditions.                                   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-³
 ³ TRACE         ³ Controls the tracing action (that is, how     ³
 ³               ³ much is displayed to the user) during proc-   ³
 ³               ³ essing of a REXX program.                     ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 



ADDRESS
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄADDRESSÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÃÄenvironmentÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄ´                          ³
 ³              ³              ÀÄexpressionÄÙ ³                          ³
 ³              ÀÄÂÄÄÄÄÄÄÄÂÄÄexpression1ÄÄÄÄÄÄÙ                          ³
 ³                ÀÄVALUEÄÙ                                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 ADDRESS temporarily or permanently changes the destination of commands. 
 Commands are strings sent to an external environment. You can send commands 
 by specifying clauses consisting of only an expression or by using the 
 ADDRESS instruction. 
 
 To send a single command to a specified environment, code an "environment," 
 a literal string or a single symbol, which is taken to be a constant, 
 followed by an "expression." (The environment name is the name of an 
 external procedure or process that can process commands.) The "expression" 
 is evaluated, and the resulting string is routed to the "environment" to be 
 processed as a command. (Enclose in quotation marks any part of the 
 expression you do not want to be evaluated.) After execution of the 
 command, "environment" is set back to whatever it was before, thus 
 temporarily changing the destination for a single command. The special 
 variable RC is set, just as it would be for other commands. (Refer to the 
 "PC DOS 7 REXX User's Guide and Reference" for more information on special 
 variables). Errors and failures in commands processed in this way are 
 trapped or traced as usual. 
 
 Example: 
 
 ADDRESS COMMAND "DIR C:\STARTUP.BAT"   /*   PC DOS   */
 
 If you specify only "environment," a lasting change of destination occurs: 
 all commands that follow (clauses that are neither REXX instructions nor 
 assignment instructions) are routed to the specified command environment, 
 until the next ADDRESS instruction is processed. The previously selected 
 environment is saved. 
 
 Examples: 
 
 Say that the environment for a text editor is registered by the name EDIT: 
 
 address COMMAND
 'DIR C:\STARTUP.BAT'
 if rc=0 then 'COPY STARTUP.BAT *.TMP'
 address EDIT
 
 Subsequent commands are passed to the editor until the next ADDRESS 
 instruction. 
 
 The address setting is the currently selected environment name. You can 
 retrieve the current address setting by using the ADDRESS built-in 
 function. 



ARG
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄARGÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³          ÀÄtemplate_listÄÙ                                            ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 ARG retrieves the argument strings provided to a program or internal 
 routine and assigns them to variables.  It is a short form of the 
 instruction: 
 
 >>ÄÄPARSE UPPER ARGÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄ><
                      ÀÄtemplate_listÄÙ
 
 
 
 The template_list is often a single template but can be several templates 
 separated by commas. If specified, each template is a list of symbols 
 separated by blanks or patterns or both. 
 
 Unless a subroutine or internal function is being processed, the strings 
 passed as parameters to the program are parsed into variables according to 
 the rules described in the section on parsing, (PARSE). 
 
 If a subroutine or internal function is being processed, the data used will 
 be the argument strings that the caller passes to the routine. 
 
 In either case, the language processor translates the passed strings to 
 uppercase (that is, lowercase a-z to uppercase A-Z) before processing them. 
 Use the PARSE ARG instruction if you do not want uppercase translation. 
 
 You can use the ARG and PARSE ARG instructions repeatedly on the same 
 source string or strings (typically with different templates). The source 
 string does not change. The only restrictions on the length or content of 
 the data parsed are those the caller imposes. 
 
 Example: 
 
 /* String passed is "Easy Rider"  */
 
 
 Arg adjective noun .
 
 
 /* Now:  ADJECTIVE  contains 'EASY'           */
 /*       NOUN       contains 'RIDER'          */
 
 If you expect more than one string to be available to the program or 
 routine, you can use a comma in the parsing template_list so each template 
 is selected in turn. 
 
 Example: 
 
 /* Function is called by  FRED('data X',1,5)    */
 
 
 Fred:  Arg string, num1, num2
 
 
 /* Now:   STRING  contains 'DATA X'             */
 /*        NUM1    contains '1'                  */
 /*        NUM2    contains '5'                  */
 
 Notes: 
 
 1.  The ARG built-in function can also retrieve or check the argument 
     strings to a REXX program or internal routine. 
 
 2.  The source of the data being processed is also made available on 
     entry to the program.  See the PARSE instruction (SOURCE option) 
     for details. 
 
 3.  Programs called as commands can have only 0 or 1 argument strings. 
     The program has 0 argument strings if it is called with the name 
     only and has 1 argument string if anything else (including blanks) 
     is included with the command. 
 



CALL
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³                   ÚÄ,ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                                  ³
 ³                                   ³                                  ³
 ³ >>ÄÄCALLÄÄÂÄnameÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³           ³         ÀÄexpressionÄÙ               ³                    ³
 ³           ÃÄOFFÄÄÂÄERRORÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                    ³
 ³           ³      ÃÄFAILUREÄÄ´                    ³                    ³
 ³           ³      ÃÄHALTÄÄÄÄÄ´                    ³                    ³
 ³           ³      ÀÄNOTREADYÄÙ                    ³                    ³
 ³           ÀÄONÄÄÂÄERRORÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ                    ³
 ³                 ÃÄFAILUREÄÄ´  ÀÄNAMEÄÄtrapnameÄÙ                      ³
 ³                 ÃÄHALTÄÄÄÄÄ´                                          ³
 ³                 ÀÄNOTREADYÄÙ                                          ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 CALL calls a routine (if you specify name) or controls the trapping of 
 certain conditions (if you specify ON or OFF). 
 
 To control trapping, you specify OFF or ON and the condition you want to 
 trap. OFF turns off the specified condition trap. ON turns on the specified 
 condition trap. 
 
 To call a routine, specify name, a literal string or symbol that is taken 
 as a constant. The name must be a symbol, which is treated literally, or a 
 literal string. The routine called can be: 
 
 An internal routine 
                A function or subroutine that is in the same 
                program as the CALL instruction or function 
                call that calls it. 
 A built-in function 
                A function (which may be called as a 
                subroutine) that is defined as part of the 
                REXX language. 
 An external routine 
                A function or subroutine that is neither 
                built-in nor in the same program as the CALL 
                instruction or function call that calls it. 
 
 
 If name is a string (that is, you specify name in quotation marks), the 
 search for internal routines is bypassed, and only a built-in function or 
 an external routine is called. Note that the names of built-in functions 
 (and, often, the names of external routines) are in uppercase; therefore, 
 the name in the literal string should be uppercase. File names can be in 
 upper, lower, or mixed case. The search for files is insensitive to case; 
 therefore, when using CALL to run a REXX subroutine contained on a disk 
 file, the case does not matter. 
 
 The called routine can optionally return a result, and when it does, the 
 CALL instruction is functionally identical with the clause: 
 
                   ÚÄ,ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                   ³
 >>ÄÄresult=name(ÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÁÄÄ)ÄÄ;ÄÄ><
                     ÀÄexpressionÄÙ
 
 If the called routine does not return a result, then you will get an error 
 if you call it as a function (as previously shown). 
 
 You can use up to 20 expressions, separated by commas. The expressions are 
 evaluated in order from left to right and form the argument strings during 
 execution of the routine. Any ARG or PARSE ARG instruction or ARG built-in 
 function in the called routine accesses these strings rather than any 
 previously active in the calling program, until control returns to the CALL 
 instruction. You can omit expressions, if appropriate, by including extra 
 commas. 
 
 The CALL then causes a branch to the routine called name, using exactly the 
 same mechanism as function calls. The search order is in the section on 
 functions but briefly is as follows: 
 
 Internal routines: 
           These are sequences of instructions inside the same 
           program, starting at the label (a clause that consists 
           of a single symbol followed by a colon) that matches 
           name in the CALL instruction. If you specify the 
           routine name in quotation marks, then an internal 
           routine is not considered for that search order. You 
           can use SIGNAL and CALL together to call an internal 
           routine whose name is determined at the time of 
           execution; this is known as a multi-way call (see 
           SIGNAL.). The RETURN instruction completes the 
           execution of an internal routine. 
 Built-in functions: 
           These are routines built into the language processor 
           for providing various functions.  They always return a 
           string that is the result of the routine. 
 External routines: 
           Users can write or use routines that are external to 
           the language processor and the calling program. An 
           external routine can be coded in REXX or in any 
           language that supports the system-dependent interfaces. 
           If the CALL instruction calls an external routine 
           written in REXX as a subroutine, you can retrieve any 
           argument strings with the ARG or PARSE ARG instructions 
           or the ARG built-in function. 
 
 
 Eventually the subroutine should process a RETURN instruction, and at that 
 point control returns to the clause following the original CALL. If the 
 RETURN instruction specified an expression, the variable RESULT is set to 
 the value of that expression. Otherwise, the variable RESULT is dropped 
 (becomes uninitialized). 
 
 An internal routine can include calls to other internal routines, as well 
 as recursive calls to itself. 
 
 Implementation maximum: The total nesting of control structures, which 
 includes internal and external routine calls, may not exceed a depth of 50. 
     



DO
 Syntax 
 
 >>ÄÄDOÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄENDÄÄ>
         ÀÄ´ repetitor ÃÄÙ  ÀÄ´ conditional ÃÄÙ     ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³
           ³           ³      ³             ³       ³              ³ ³
                                                    ÀÄÄÄinstructionÄÁÄÙ
 >ÄÄÂÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
    ÀÄnameÄÙ
 
 REPETITOR:
 ÃÄÄÂÄname=expriÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³             ÀÄTOÄÄexprtÄÙ  ÀÄBYÄÄexprbÄÙ  ÀÄFORÄÄexprfÄÙ ³
    ÃÄFOREVERÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ÀÄexprrÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 CONDITIONAL:
 ÃÄÄÂÄWHILEÄÄexprwÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ÀÄUNTILÄÄexpruÄÙ
 
 DO groups instructions together and optionally processes them repetitively. 
 During repetitive execution, a control variable ("name") can be stepped 
 through some range of values. 
 
 Syntax Notes: 
   
   o The exprr, expri, exprb, exprt, and exprf options (if present) are 
     any expressions that evaluate to a number. The exprr and exprf 
     options are further restricted to result in a positive whole number 
     or zero. If necessary, the numbers are rounded according to the 
     setting of NUMERIC DIGITS. 
   o The exprw or expru options (if present) can be any expression that 
     evaluates to 1 or 0. 
   o The TO, BY, and FOR phrases can be in any order, if used, and are 
     evaluated in the order in which they are written. 
   o The instruction can be any instruction, including assignments, 
     commands, and keyword instructions (including any of the more 
     complex constructs such as IF, SELECT, and the DO instruction 
     itself). 
   o The subkeywords WHILE and UNTIL are reserved within a DO 
     instruction, in that they cannot be used as symbols in any of the 
     expressions. Similarly, TO, BY, and FOR cannot be used in expri, 
     exprt, exprb, or exprf. FOREVER is also reserved, but only if it 
     immediately follows the keyword DO and an equal sign does not 
     follow it. 
   o The exprb option defaults to 1, if relevant. 
   
 
 Double-click on Repetitive DO Loops to continue. 



Repetitive DO Loops
 
 
 If a DO instruction has a repetitor phrase or a conditional phrase or both, 
 the group of instructions forms a repetitive DO loop. The instructions are 
 processed according to the repetitor phrase, optionally modified by the 
 conditional phrase. 
 
 Double-click on Simple Repetitive Loops to continue. 



Simple Repetitive Loops
 
 
 A simple repetitive loop is a repetitive DO loop in which the repetitor 
 phrase is an expression that evaluates to a count of the iterations. 
 
 If repetitor is omitted but there is a conditional or if the repetitor is 
 FOREVER, the group of instructions is nominally processed forever, that is, 
 until the condition is satisfied or a REXX instruction is processed that 
 ends the loop (for example, LEAVE). 
 
 In the simple form of a repetitive loop, exprr is evaluated immediately 
 (and must result in a positive whole number or zero), and the loop is then 
 processed that many times. 
 
 Example: 
 
 /* The two instructions between DO and END are both  */
 /* processed if A has the value "3".                 */
 If a=3 then Do
               a=a+2
               Say 'Smile!'
             End
 
 Example: 
 
 /* This displays "Hello" five times */
 Do 5
   say 'Hello'
   end
 
 Note that, similar to the distinction between a command and an assignment, 
 if the first token of exprr is a symbol and the second token is (or starts 
 with) =, the controlled form of repetitor is expected. 
 
 Double-click on Controlled Repetitive Loops to continue.  



Controlled Repetitive Loops
 
 
 The controlled form specifies name, a "control variable" that is assigned 
 an initial value (the result of expri, formatted as though 0 had been 
 added) before the first execution of the instruction list. The variable is 
 then stepped (by adding the result of exprb) before the second and 
 subsequent times that the instruction list is processed. 
 
 The instruction list is processed repeatedly while the end condition 
 (determined by the result of exprt) is not met. If exprb is positive or 0, 
 the loop is ended when name is greater than exprt. If negative, the loop is 
 ended when name is less than exprt. 
 
 The expri, exprt, and exprb options must result in numbers.  They are 
 evaluated only one time, before the loop begins and before the control 
 variable is set to its initial value. The default value for exprb is 1. If 
 exprt is omitted, the loop runs indefinitely unless some other condition 
 stops it. 
 
 Example: 
 
 Do I=3 to -2 by -1        /* Displays:   */
   say i                   /*      3      */
   end                     /*      2      */
                           /*      1      */
                           /*      0      */
                           /*      -1     */
                           /*      -2     */
 
 The numbers do not have to be whole numbers: 
 
 Example: 
 
 I=0.3                     /* Displays:   */
 Do Y=I to I+4 by 0.7      /*     0.3     */
   say Y                   /*     1.0     */
   end                     /*     1.7     */
                           /*     2.4     */
                           /*     3.1     */
                           /*     3.8     */
 
 The control variable can be altered within the loop, and this may affect 
 the iteration of the loop. Altering the value of the control variable is 
 not usually considered good programming practice, though it may be 
 appropriate in certain circumstances. 
 
 Note that the end condition is tested at the start of each iteration (and 
 after the control variable is stepped, on the second and subsequent 
 iterations). Therefore, if the end condition is met immediately, the group 
 of instructions can be skipped entirely. Note also that the control 
 variable is referred to by name. If (for example) the compound name A.I is 
 used for the control variable, altering I within the loop causes a change 
 in the control variable. 
 
 The execution of a controlled loop can be bounded further by a FOR phrase. 
 In this case, you must specify exprf, and it must evaluate to a positive 
 whole number or zero. This acts just like the repetition count in a simple 
 repetitive loop, and sets a limit to the number of iterations around the 
 loop if no other condition stops it. Like the TO and BY expressions, it is 
 evaluated only one time-when the DO instruction is first processed and 
 before the control variable receives its initial value. Like the TO 
 condition, the FOR condition is checked at the start of each iteration. 
 
 Example: 
 
 Do Y=0.3 to 4.3 by 0.7 for 3  /* Displays:    */
   say Y                       /*     0.3      */
   end                         /*     1.0      */
                               /*     1.7      */
 
 In a controlled loop, the name describing the control variable can be 
 specified on the END clause. This name must match name in the DO clause in 
 all respects except case (note that no substitution for compound variables 
 is carried out); a syntax error results if it does not. This enables the 
 nesting of loops to be checked automatically, with minimal overhead. 
 
 Example: 
 
 Do K=1 to 10
   ...
   ...
   End k  /* Checks that this is the END for K loop */
 
 Note: The NUMERIC settings may affect the successive values of the control 
 variable, because REXX arithmetic rules apply to the computation of 
 stepping the control variable. 
 
 Double-click on Conditional Phrases (While and UNTIL) to continue. 



Conditional Phrases (WHILE and UNTIL)
 
 
 A conditional phrase can modify the iteration of a repetitive DO loop. It 
 may cause the termination of a loop. It can follow any of the forms of 
 repetitor (none, FOREVER, simple, or controlled). If you specify WHILE or 
 UNTIL, exprw or expru, respectively, is evaluated each time around the loop 
 using the latest values of all variables (and must evaluate to either 0 or 
 1), and the loop is ended if exprw evaluates to 0 or expru evaluates to 1. 
 
 For a WHILE loop, the condition is evaluated at the top of the group of 
 instructions.  For an UNTIL loop, the condition is evaluated at the 
 bottom-before the control variable has been stepped. 
 
 Example: 
 
 Do I=1 to 10 by 2 until i>6
   say i
   end
 /* Displays: "1" "3" "5" "7" */
 
 Note: Using the LEAVE or ITERATE instructions can also modify the execution 
 of repetitive loops.  



DROP
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³           ÚÄÄÄÄÄÄÄÄÄÄ¿                                                ³
 ³                     ³                                                ³
 ³ >>ÄÄDROPÄÄÄÂÄnameÄÄÄÂÁÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³            ÀÄ(name)ÄÙ                                                 ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 DROP "unassigns" variables, that is, restores them to their original 
 uninitialized state. If name is not enclosed in parentheses, it identifies 
 a variable you want to drop and must be a symbol that is a valid variable 
 name, separated from any other name by one or more blanks or comments. 
 
 If parentheses enclose a single name, then its value is used as a 
 subsidiary list of variables to drop. (Blanks are not necessary either 
 inside or outside the parentheses, but you can add them if desired.) This 
 subsidiary list must follow the same rules as the original list (that is, 
 be valid variable names, separated by blanks) except that no parentheses 
 are allowed. 
 
 Variables are dropped in sequence from left to right. It is not an error to 
 specify a name more than one time or to DROP a variable that is not known. 
 If an exposed variable is named (see PROCEDURE), the variable in the older 
 generation is dropped. 
 
 Example: 
 
 j=4
 Drop  a z.3 z.j
 /* Drops the variables: A, Z.3, and Z.4              */
 /* so that reference to them returns their names.    */
 
 In the following example, a variable name in parentheses is used as a 
 subsidiary list. 
 
 Example: 
 
 mylist='c d e'
 drop (mylist) f
 /* Drops the variables C, D, E, and F          */
 /* Does not drop MYLIST                        */
 
 Specifying a stem (that is, a symbol that contains only one period, as the 
 last character), drops all variables starting with that stem. 
 
 Example: 
 
 Drop  z.
 /* Drops all variables with names starting with Z. */
 
 



EXIT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄEXITÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³           ÀÄexpressionÄÙ                                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 EXIT leaves a program unconditionally. Optionally. EXIT returns a character 
 string to the caller. The program is stopped immediately, even if an 
 internal routine is currently being run.  If no internal routine is active, 
 RETURN and EXIT are identical in their effect on the program that is being 
 run. 
 
 If you specify expression, it is evaluated and the string resulting from 
 the evaluation is passed back to the caller when the program stops. 
 
 Example: 
 
 j=3
 Exit j*4
 /* Would exit with the string '12' */
 
 If you do not specify expression, no data is passed back to the caller. If 
 the program was called as an external function, this is detected as an 
 error-either immediately (if RETURN was used), or on return to the caller 
 (if EXIT was used). 
 
 "Running off the end" of the program is always equivalent to the 
 instruction EXIT, in that it stops the whole program and returns no result 
 string.  



IF
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄIFÄÄexpressionÄÄÂÄÄÄÂÄÄTHENÄÄÂÄÄÄÂÄÄinstructionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ> ³
 ³                     ÀÄ;ÄÙ        ÀÄ;ÄÙ                                ³
 ³                                                                       ³
 ³ >ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³    ÀÄELSEÄÄÂÄÄÄÂÄÄinstructionÄÙ                                       ³
 ³            ÀÄ;ÄÙ                                                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 IF conditionally processes an instruction or group of instructions 
 depending on the evaluation of the expression. The expression is evaluated 
 and must result in 0 or 1. 
 
 The instruction after the THEN is processed only if the result is 1 (true). 
 If you specify an ELSE, the instruction after the ELSE is processed only if 
 the result of the evaluation is 0 (false). 
 
 Example: 
 
 if answer='YES' then say 'OK!'
                 else say 'Why not?'
 
 Remember that if the ELSE clause is on the same line as the last clause of 
 the THEN part, you need a semicolon before the ELSE. 
 
 Example: 
 
 if answer='YES' then say 'OK!';  else say 'Why not?'
 
 The ELSE binds to the nearest IF at the same level. You can use the NOP 
 instruction to eliminate errors and possible confusion when IF constructs 
 are nested, as in the following example. 
 
 Example: 
 
 If answer = 'YES' Then
    If name = 'FRED' Then
       say 'OK, Fred.'
    Else
       nop
 Else
    say 'Why not?'
 
 Notes: 
 
 1.  The instruction can be any assignment, command, or keyword 
     instruction, including any of the more complex constructs such as 
     DO, SELECT, or the IF instruction itself.  A null clause is not an 
     instruction, so putting an extra semicolon (or label) after the 
     THEN or ELSE is not equivalent to putting a dummy instruction. The 
     NOP instruction is provided for this purpose. 
 
 2.  The symbol THEN cannot be used within expression, because the 
     keyword THEN is treated differently, in that it need not start a 
     clause.  This allows the expression on the IF clause to be ended by 
     the THEN, without a ; being required. If this were not so, people 
     who are accustomed to other computer languages would experience 
     considerable difficulties. 
 



INTERPRET
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄINTERPRETÄÄexpressionÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 INTERPRET processes instructions that have been built dynamically by 
 evaluating expression. 
 
 The expression is evaluated and is then processed (interpreted) just as 
 though the resulting string were a line inserted into the program (and 
 bracketed by a DO; and an END;). 
 
 Any instructions (including INTERPRET instructions) are allowed, but note 
 that constructions such as DO...END and SELECT...END must be complete. For 
 example, a string of instructions being interpreted cannot contain a LEAVE 
 or ITERATE instruction (valid only within a repetitive DO loop) unless it 
 also contains the whole repetitive DO...END construct. 
 
 A semicolon is implied at the end of the expression during execution, if 
 one was not supplied. 
 
 Example: 
 
 data='FRED'
 interpret data '= 4'
 /* 1) Builds the string  "FRED = 4"         */
 /* 2) Processes:  FRED = 4;                 */
 /* Thus the variable FRED is set to "4"     */
 
 Example: 
 
 data='do 3; say "Hello there!"; end'
 interpret data        /* Displays:          */
                       /*  Hello there!      */
                       /*  Hello there!      */
                       /*  Hello there!      */
 
 Notes: 
 
 1.  Labels within the interpreted string are not permanent and are, 
     therefore, an error. 
 
 2.  If you are new to the concept of the INTERPRET instruction and are 
     getting results that you do not understand, you may find that 
     executing it with TRACE R or TRACE I in effect is helpful.  See 
     TRACE for more information. 
 



ITERATE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄITERATEÄÄÂÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÀÄnameÄÙ                                                 ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 ITERATE alters the flow within a repetitive DO loop (that is, any DO 
 construct other than that with a simple DO). 
 
 Execution of the group of instructions stops, and control is passed to the 
 DO instruction just as though the END clause had been encountered. The 
 control variable (if any) is incremented and tested, as usual, and the 
 group of instructions is processed again, unless the DO instruction ends 
 the loop. 
 
 The name is a symbol, taken as a constant. If name is not specified, 
 ITERATE steps the innermost active repetitive loop. If name is specified, 
 it must be the name of the control variable of a currently active loop 
 (which may be the innermost), and this is the loop that is stepped. Any 
 active loops inside the one selected for iteration are ended (as though by 
 a LEAVE instruction). 
 
 Example: 
 
 do i=1 to 4
   if i=2 then iterate
   say i
   end
 /* Displays the numbers:  "1" "3" "4" */
 
 Notes: 
 
 1.  If specified, name must match the symbol naming the control 
     variable in the DO clause in all respects except case. No 
     substitution for compound variables is carried out when the 
     comparison is made. 
 2.  A loop is active if it is currently being processed. If a 
     subroutine is called (or an INTERPRET instruction is processed) 
     during execution of a loop, the loop becomes inactive until the 
     subroutine has returned or the INTERPRET instruction has completed. 
     ITERATE cannot be used to step an inactive loop. 
 3.  If more than one active loop uses the same control variable, 
     ITERATE selects the innermost loop. 
 



LEAVE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLEAVEÄÄÂÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³            ÀÄnameÄÙ                                                   ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 LEAVE causes an immediate exit from one or more repetitive DO loops (that 
 is, any DO construct other than a simple DO). 
 
 Processing of the group of instructions is ended, and control is passed to 
 the instruction following the END clause, just as though the END clause had 
 been encountered and the termination condition had been met. However, on 
 exit, the control variable (if any) will contain the value it had when the 
 LEAVE instruction was processed. 
 
 The name is a symbol, taken as a constant. If name is not specified, LEAVE 
 ends the innermost active repetitive loop. If name is specified, it must be 
 the name of the control variable of a currently active loop (which may be 
 the innermost), and that loop (and any active loops inside it) is then 
 ended. Control then passes to the clause following the END that matches the 
 DO clause of the selected loop. 
 
 Example: 
 
 do i=1 to 5
   say i
   if i=3 then leave
   end
 /* Displays the numbers:  "1" "2" "3" */
 
 Notes: 
 
 1.  If specified, name must match the symbol naming the control 
     variable in the DO clause in all respects except case. No 
     substitution for compound variables is carried out when the 
     comparison is made. 
 2.  A loop is active if it is currently being processed.  If a 
     subroutine is called (or an INTERPRET instruction is processed) 
     during execution of a loop, the loop becomes inactive until the 
     subroutine has returned or the INTERPRET instruction has completed. 
     LEAVE cannot be used to end an inactive loop. 
 3.  If more than one active loop uses the same control variable, LEAVE 
     selects the innermost loop. 
 



NOP
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄNOPÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 NOP is a dummy instruction that has no effect.  It can be useful as the 
 target of a THEN or ELSE clause: 
 
 Example: 
 
 Select
    when a=c then nop           /* Do nothing */
    when a>c then say 'A > C'
    otherwise     say 'A < C'
 end
 
 Note: Putting an extra semicolon instead of the NOP would merely insert a 
 null clause, which would be ignored. The second WHEN clause would be seen 
 as the first instruction expected after the THEN, and would, therefore, be 
 treated as a syntax error. NOP is a true instruction, however, and is, 
 therefore, a valid target for the THEN clause. 



NUMERIC
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄNUMERICÄÄÂÄDIGITSÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ³         ÀÄexpression1ÄÙ          ³                     ³
 ³              ³       ÚÄSCIENTIFICÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³                     ³
 ³              ÃÄFORMÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ´                     ³
 ³              ³       ÃÄENGINEERINGÄÄÄÄÄÄÄÄÄÄÄÄ´ ³                     ³
 ³              ³       ÀÄÂÄÄÄÄÄÄÄÂÄÄexpression2ÄÙ ³                     ³
 ³              ³         ÀÄVALUEÄÙ                ³                     ³
 ³              ÀÄFUZZÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ                     ³
 ³                      ÀÄexpression3ÄÙ                                  ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 NUMERIC changes the way in which a program carries out arithmetic 
 operations. Following is a summary of options for this instruction: 
 
 NUMERIC DIGITS 
           controls the precision to which arithmetic operations 
           and arithmetic built-in functions are evaluated. If you 
           omit expression1, the precision defaults to 9 digits. 
           Otherwise, expression1 must evaluate to a positive 
           whole number and must be larger than the current 
           NUMERIC FUZZ setting. 
           
           There is no limit to the value for DIGITS (except the 
           amount of storage available), but note that high 
           precisions are likely to require a good deal of 
           processing time. It is recommended that you use the 
           default value wherever possible. 
           
           You can retrieve the current NUMERIC DIGITS setting 
           with the DIGITS built-in function. 
 
 NUMERIC FORM 
           controls which form of exponential notation REXX uses 
           for the result of arithmetic operations and arithmetic 
           built-in functions. This may be either SCIENTIFIC (in 
           which case only one, nonzero digit appears before the 
           decimal point) or ENGINEERING (in which case the power 
           of 10 is always a multiple of 3). The default is 
           SCIENTIFIC. The subkeywords SCIENTIFIC or ENGINEERING 
           set the FORM directly, or it is taken from the result 
           of evaluating the expression (expression2) that follows 
           VALUE. The result in this case must be either 
           SCIENTIFIC or ENGINEERING. You can omit the subkeyword 
           VALUE if expression2 does not begin with a symbol or a 
           literal string (that is, if it starts with a special 
           character, such as an operator character or 
           parenthesis). 
           
           You can retrieve the current NUMERIC FORM setting with 
           the FORM built-in function. 
 
 NUMERIC FUZZ 
           controls how many digits, at full precision, are 
           ignored during a numeric comparison operation. If you 
           omit expression3, the default is 0 digits. Otherwise, 
           expression3 must evaluate to 0 or a positive whole 
           number, rounded if necessary according to the current 
           NUMERIC DIGITS setting, and must be smaller than the 
           current NUMERIC DIGITS setting. 
           
           NUMERIC FUZZ temporarily reduces the value of NUMERIC 
           DIGITS by the NUMERIC FUZZ value during every numeric 
           comparison. The numbers are subtracted under a 
           precision of DIGITS minus FUZZ digits during the 
           comparison and are then compared with 0. 
           
           You can retrieve the current NUMERIC FUZZ setting with 
           the FUZZ built-in function. 
 
 
 Note: The three numeric settings are automatically saved across internal 
 and external subroutine and function calls. See the CALL instruction for 
 more details.  



PARSE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                             ³
 ³ >>ÄÄPARSEÄÄÂÄÄÄÄÄÄÄÂÄÄÂÄARGÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄ>³
 ³            ÀÄUPPERÄÙ  ÃÄLINEINÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  ÀÄtemplate_listÄÙ    ³
 ³                       ÃÄPULLÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                       ³
 ³                       ÃÄSOURCEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                       ³
 ³                       ÃÄVALUEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄWITHÄ´                       ³
 ³                       ³        ÀÄexpressionÄÙ       ³                       ³
 ³                       ÃÄVARÄÄnameÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                       ³
 ³                       ÀÄVERSIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                       ³
 ³                                                                             ³
 ³                                                                             ³
 >ÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><³
 ³                                                                             ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 PARSE assigns data (from various sources) to one or more variables. 
 
 The template_list is often a single template but may be several templates 
 separated by commas. If specified, each template is a list of symbols 
 separated by blanks or patterns or both.  Additional information on 
 templates can be found in the "PC DOS 7 REXX User's Guide and Reference." 
 
 Parsing splits up the data in a source string and assigns pieces of it into 
 the variables names in a template.  A template is a model that specifies 
 how to split the source string.  The simplest kind of template consist of 
 only a list of variable names. 
 
 Here is an example: 
 
     parse value 'one two three' with var1 var2 var3
 
 The template is var1 var2 var3 in this instruction. 
 
 See the "PC DOS 7 REXX User's Guide and Reference" for more information 
 about parsing and template_list. 
 
 If you specify the UPPER option, the data to be parsed is first translated 
 to uppercase (that is, lowercase a-z to uppercase A-Z). Otherwise, no 
 uppercase translation takes place during the parsing. 
 
 The following list describes the data for each variant of the PARSE 
 instruction. 
 
 PARSE ARG 
           parses the string or strings passed to a program or 
           internal routine as input arguments. (See the ARG 
           instruction for details and examples.) 
           
           Note: You can also retrieve or check the argument 
           strings to a REXX program or internal routine with the 
           ARG built-in function. 
 
 PARSE LINEIN 
           parses the next line from the default input stream. 
           PARSE LINEIN is a shorter form of the instruction: 
           
           >>ÄÄPARSE VALUE LINEIN() WITHÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄ><
                                          ÀÄtemplate_listÄÙ
           
           If no line is available, program execution will usually 
           pause until a line is complete. Note that PARSE LINEIN 
           should be used only when direct access to the character 
           input stream is necessary. Usual line-by-line dialogue 
           with the user should be carried out with the PULL or 
           PARSE PULL instructions, to maintain generality. 
           
           To check if any lines are available in the default 
           input stream, use the built-in function LINES. 
 
 PARSE PULL 
           parses the next string from the internal data queue. If 
           the internal data queue is empty, PARSE PULL reads a 
           line from the default input stream (the user's 
           terminal), and the program pauses, if necessary, until 
           a line is complete. You can add data to the head or 
           tail of the queue by using the PUSH and QUEUE 
           instructions, respectively. You can find the number of 
           lines currently in the queue with the QUEUED built-in 
           function. The queue remains active as long as the 
           language processor is active. 
           
           Note: PULL and PARSE PULL read first from the current 
           data queue; if the queue is empty, they read from the 
           default input stream, STDIN (generally the keyboard). 
           (See the PULL instruction for further details.) 
 
 PARSE SOURCE 
           parses data describing the source of the program 
           running. The language processor returns a string that 
           is fixed (does not change) while the program is 
           running. 
           
           The source string contains the characters PC DOS, 
           followed by either COMMAND, FUNCTION, or SUBROUTINE, 
           depending on whether the program was called as a host 
           command or from a function call in an expression or 
           using the CALL instruction. These two tokens are 
           followed by the complete path specification of the 
           program file. 
           
           The string parsed might, therefore, look like this: 
           
           DOS COMMAND C:\DOS\RX.BAT
           
           
 
 PARSE VALUE 
           parses the data that is the result of evaluating 
           "expression." If you specify no "expression," then the 
           null string is used. Note that WITH is a subkeyword in 
           this context and cannot be used as a symbol within 
           "expression." 
           
           Thus, for example: 
           
           PARSE VALUE time() WITH  hours ':' mins ':' secs
           
           gets the current time and splits it into its 
           constituent parts. 
 
 PARSE VAR name 
           parses the value of the variable name. The name must be 
           a symbol that is valid as a variable name (that is, it 
           cannot start with a period or a digit).  Note that the 
           variable name is not changed unless it appears in the 
           template, so that for example: 
           
           PARSE VAR string word1 string
           
           removes the first word from string, puts it in the 
           variable word1, and assigns the remainder back to 
           string.  Similarly 
           
           PARSE UPPER VAR string word1 string
           
           in addition translates the data from string to 
           uppercase before it is parsed. 
 
 PARSE VERSION 
           parses information describing the language level and 
           the date of the language processor.  This information 
           consists of five words (delimited by blanks): first the 
           string REXXSAA, then the language level description 
           (for example, 4.00, 13 June 1989). 
 



PROCEDURE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄPROCEDUREÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                ³         ÚÄÄÄÄÄÄÄÄÄÄ¿ ³                               ³
 ³                ³                   ³ ³                               ³
 ³                ÀÄEXPOSEÄÄÄÂÄnameÄÄÄÂÁÄÙ                               ³
 ³                           ÀÄ(name)ÄÙ                                  ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 PROCEDURE, within an internal routine (subroutine or function), protects 
 variables by making them unknown to the instructions that follow it. After 
 a RETURN instruction is processed, the original variables environment is 
 restored and any variables used in the routine (that were not exposed) are 
 dropped. (An exposed variable is one belonging to a caller of a routine 
 that the PROCEDURE instruction has exposed. When the routine refers to or 
 alters the variable, the original (caller's) copy of the variable is used.) 
 An internal routine need not include a PROCEDURE instruction; in this case 
 the variables it is manipulating are those the caller "owns." If used, the 
 PROCEDURE instruction must be the first instruction processed after the 
 CALL or function invocation; that is, it must be the first instruction 
 following the label. 
 
 If you use the EXPOSE option, any variable specified by name is exposed.  
 Any reference to it (including setting and dropping) refers to the 
 variables environment the caller owns. Hence, the values of existing 
 variables are accessible, and any changes are persistent even on RETURN 
 from the routine. If name is not enclosed in parentheses, it identifies a 
 variable you want to expose and must be a symbol that is a valid variable 
 name, separated from any other name with one or more blanks. 
 
 If parentheses enclose a single name, then, after the variable name is 
 exposed, the value of name is immediately used as a subsidiary list of 
 variables. (Blanks are not necessary either inside or outside the 
 parentheses, but you can add them if desired.) This subsidiary list must 
 follow the same rules as the original list (that is, valid variable names, 
 separated by blanks) except that no parentheses are allowed. 
 
 Variables are exposed in sequence from left to right. It is not an error to 
 specify a name more than one time, or to specify a name that the caller has 
 not used as a variable. 
 
 Any variables in the main program that are not exposed are still protected. 
 Therefore, some limited set of the caller's variables can be made 
 accessible, and these variables can be changed (or new variables in this 
 set can be created).  All these changes are visible to the caller upon 
 RETURN from the routine. 
 
 Example: 
 
 /* This is the main REXX program */
 j=1; z.1='a'
 call toft
 say j k m       /* Displays "1 7 M"          */
 exit
 
 /* This is a subroutine     */
 toft: procedure expose j k z.j
    say j k z.j  /* Displays "1 K a"          */
    k=7; m=3     /* Note: M is not exposed    */
    return
 
 Note that if Z.J in the EXPOSE list had been placed before J, the 
 caller's value of J would not have been visible at that time, so Z.1 would 
 not have been exposed. 
 
 The variables in a subsidiary list are also exposed from left to right. 
 
 



PULL
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄPULLÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³           ÀÄtemplate_listÄÙ                                           ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 PULL reads a string from the head of the internal data queue. It is just a 
 short form of the instruction: 
 
 >>ÄÄPARSE UPPER PULLÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄ><
                       ÀÄtemplate_listÄÙ
 
 The current head-of-queue is read as one string.  Without a template_list 
 specified, no further action is taken (and the string is thus effectively 
 discarded). If specified, a template_list is usually a single template, 
 which is a list of symbols separated by blanks or patterns or both. (The 
 template_list can be several templates separated by commas, but PULL parses 
 only one source string; if you specify several comma-separated templates, 
 variables in templates other than the first one are assigned the null 
 string.) The string is translated to uppercase (that is, lowercase a-z to 
 uppercase A-Z) and then parsed into variables according to the rules 
 described in the section on parsing, (PARSE). Use the PARSE PULL 
 instruction if you do not desire uppercase translation. 
 
 Note: If the current data queue is empty, PULL reads instead from STDIN 
 (generally the keyboard). The length of data read by the PULL instruction 
 is restricted to the length of strings contained by variables. 
 
 Example: 
 
 Say 'Do you want to erase the file?  Answer Yes or No:'
 Pull answer .
 if answer='NO' then say 'The file will not be erased.'
 
 Here the dummy placeholder, a period (.), is used on the template to 
 isolate the first word the user enters. 
 
 If the internal data queue is empty, a line is read from the default input 
 stream and the program pauses, if necessary, until a line is complete. 
 (This is as though PARSE UPPER LINEIN had been processed.) 
 
 The QUEUED built-in function returns the number of lines currently in the 
 external data queue. 



PUSH
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄPUSHÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³           ÀÄexpressionÄÙ                                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 PUSH stacks the string resulting from the evaluation of expression LIFO 
 (Last In, First Out) onto the internal data queue. 
 
 If you do not specify expression, a null string is stacked. 
 
 Example: 
 
 a='Fred'
 push       /* Puts a null line onto the queue */
 push a 2   /* Puts "Fred 2"    onto the queue */
 
 The QUEUED built-in function returns the number of lines currently in the 
 internal data queue. 



QUEUE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄQUEUEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³            ÀÄexpressionÄÙ                                             ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 QUEUE appends the string resulting from expression to the tail of the 
 internal data queue. That is, it is added FIFO (First In, First Out). 
 
 If you do not specify expression, a null string is queued. 
 
 Example: 
 
 a='Toft'
 queue a 2  /* Enqueues "Toft 2" */
 queue      /* Enqueues a null line behind the last */
 
 The QUEUED built-in function returns the number of lines currently in the 
 external data queue.  



RETURN
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄRETURNÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³             ÀÄexpressionÄÙ                                            ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 RETURN returns control (and possibly a result) from a REXX program or 
 internal routine to the point of its invocation. 
 
 If no internal routine (subroutine or function) is active, RETURN and EXIT 
 are identical in their effect on the program that is being run. 
 
 If a subroutine is being run (see the CALL instruction), expression (if 
 any) is evaluated, control passes back to the caller, and the REXX special 
 variable RESULT is set to the value of expression. If expression is 
 omitted, the special variable RESULT is dropped (becomes uninitialized). 
 The various settings saved at the time of the CALL (tracing, addresses, and 
 so forth) are also restored. (See CALL.) 
 
 If a function is being processed, the action taken is identical, except 
 that expression must be specified on the RETURN instruction. The result of 
 expression is then used in the original expression at the point where the 
 function was called. See Functions for more details. 
 
 If a PROCEDURE instruction was processed within the routine (subroutine or 
 internal function), all variables of the current generation are dropped 
 (and those of the previous generation are exposed) after expression is 
 evaluated and before the result is used or assigned to RESULT. 



SAY
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSAYÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³          ÀÄexpressionÄÙ                                               ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 SAY writes a line to the output stream. This typically displays it to the 
 user, but the output destination can depend on the implementation. The 
 result of expression may be of any length. If you omit expression, the null 
 string is written. 
 
 The SAY instruction is a shorter form of the instruction: 
 
 >>ÄÄCALL LINEOUTÄÄ,ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄ><
                      ÀÄexpressionÄÙ
 
 except that: 
   
   o SAY does not affect the special variable RESULT 
   
   o If you use SAY and omit expression, a null string is used 
   
   o CALL LINEOUT can raise NOTREADY; SAY cannot. 
   
 
 Notes: 
 
 1.  Data from the SAY instruction is sent to the default output stream 
     (STDOUT). However, the standard rules for redirecting output apply 
     to SAY output. 
 2.  The SAY instruction does not format data; line wrapping is handled 
     by the operating system. However formatting is accomplished, the 
     output data remains a single logical line. 
 
 
 Example: 
 
 data=100
 Say data 'divided by 4 =>' data/4
 /* Displays: "100 divided by 4 => 25"  */
 
 



SELECT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ³
 ³                                                                 ³    ³
 ³ >>ÄÄSELECT;ÄÄÄÄWHENÄÄexpressionÄÄÂÄÄÄÂÄÄTHENÄÄÂÄÄÄÂÄÄinstructionÄÁÄÄ> ³
 ³                                  ÀÄ;ÄÙ        ÀÄ;ÄÙ                   ³
 ³                                                                       ³
 ³ >ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄENDÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ< ³
 ³    ÀÄOTHERWISEÄÄÂÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ                          ³
 ³                 ÀÄ;ÄÙ  ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³                            ³
 ³                        ³              ³ ³                            ³
 ³                        ÀÄÄÄinstructionÄÁÄÙ                            ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 SELECT conditionally calls one of several alternative instructions. 
 
 Each expression after a WHEN is evaluated in turn and must result in 0 or 
 1. If the result is 1, the instruction following the associated THEN (which 
 may be a complex instruction such as IF, DO, or SELECT) is processed and 
 control then passes to the END. If the result is 0, control passes to the 
 next WHEN clause. 
 
 If none of the WHEN expressions evaluates to 1, control passes to the 
 instructions, if any, after OTHERWISE. In this situation, the absence of an 
 OTHERWISE causes an error (but note that you can omit the instruction list 
 that follows OTHERWISE). 
 
 Example: 
 
   balance=100
   check=50
   balance = balance - check
   Select
     when balance > 0 then
          say 'Congratulations! You still have' balance 'dollars left.'
     when balance = 0 then do
          say 'Warning, Balance is now zero!  STOP all spending.'
          say "You cut it close this month! Hope you do not have any"
          say "checks left outstanding."
          end
     Otherwise
          say "You have just overdrawn your account."
          say "Your balance now shows" balance "dollars."
   end  /* Select */
 
 Notes: 
 
 1.  The instruction can be any assignment, command, or keyword 
     instruction, including any of the more complex constructs such as 
     DO, IF, or the SELECT instruction itself. 
 2.  A null clause is not an instruction, so putting an extra semicolon 
     (or label) after a THEN clause is not equivalent to putting a dummy 
     instruction. The NOP instruction is provided for this purpose. 
 3.  The symbol THEN cannot be used within expression, because the 
     keyword THEN is treated differently, in that it need not start a 
     clause.  This allows the expression on the WHEN clause to be ended 
     by the THEN without a ; (delimiter) being required. 
 



SIGNAL
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSIGNALÄÄÂÄlabelnameÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³             ÃÄÂÄÄÄÄÄÄÄÂÄÄexpressionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                  ³
 ³             ³ ÀÄVALUEÄÙ                            ³                  ³
 ³             ÃÄOFFÄÄÂÄERRORÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                  ³
 ³             ³      ÃÄFAILUREÄÄ´                    ³                  ³
 ³             ³      ÃÄHALTÄÄÄÄÄ´                    ³                  ³
 ³             ³      ÃÄNOTREADYÄ´                    ³                  ³
 ³             ³      ÃÄNOVALUEÄÄ´                    ³                  ³
 ³             ³      ÀÄSYNTAXÄÄÄÙ                    ³                  ³
 ³             ÀÄONÄÄÂÄERRORÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ                  ³
 ³                   ÃÄFAILUREÄÄ´  ÀÄNAMEÄÄtrapnameÄÙ                    ³
 ³                   ÃÄHALTÄÄÄÄÄ´                                        ³
 ³                   ÃÄNOTREADYÄ´                                        ³
 ³                   ÃÄNOVALUEÄÄ´                                        ³
 ³                   ÀÄSYNTAXÄÄÄÙ                                        ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 SIGNAL causes an unusual change in the flow of control (if you specify 
 labelname or VALUE expression), or controls the trapping of certain 
 conditions (if you specify ON or OFF). 
 
 To control trapping, you specify OFF or ON and the condition you want to 
 trap. OFF turns off the specified condition trap. ON turns on the specified 
 condition trap. 
 
 To change the flow of control, a label name is derived from labelname or 
 taken from the result of evaluating the expression after VALUE. The 
 labelname you specify must be a literal string or symbol that is taken as a 
 constant. If you use a symbol for labelname, the search is independent of 
 alphabetic case. If you use a literal string, the characters should be in 
 uppercase. This is because the language processor translates all labels to 
 uppercase, regardless of how you enter them in the program. Similarly, for 
 SIGNAL VALUE, the expression must evaluate to a string in uppercase or the 
 language processor does not find the label. You can omit the subkeyword 
 VALUE if expression does not begin with a symbol or literal string (that 
 is, if it starts with a special character, such as an operator character or 
 parenthesis). All active pending DO, IF, SELECT, and INTERPRET instructions 
 in the current routine are then ended (that is, they cannot be resumed). 
 Control then passes to the first label in the program that matches the 
 given name, as though the search had started from the top of the program. 
 
 Example: 
 
 Signal fred;  /* Transfer control to label FRED below */
   ....
   ....
 Fred: say 'Hi!'
 
 Because the search effectively starts at the top of the program, if 
 duplicates are present, control always passes to the first occurrence of 
 the label in the program. 
 
 When control reaches the specified label, the line number of the SIGNAL 
 instruction is assigned to the special variable SIGL. This can aid 
 debugging because you can use SIGL to determine the source of a transfer of 
 control to a label. 
 
 Using SIGNAL VALUE: 
 
 The VALUE form of the SIGNAL instruction allows a branch to a label whose 
 name is determined at the time of execution. This can safely effect a 
 multi-way CALL (or function call) to internal routines because any DO 
 loops, and so forth, in the calling routine are protected against 
 termination by the call mechanism. 
 
 Example: 
 
 fred='PETE'
 call multiway fred, 7
    ....
    ....
 exit
 Multiway: procedure
    arg label .              /* One word, uppercase                  */
                             /* Can add checks for valid labels here */
    signal value label       /* Transfer control to wherever         */
    ....
 Pete: say arg(1) '!' arg(2) /* Displays: "PETE ! 7"                 */
    return
 
 



TRACE
 Syntax 
 
 >>ÄÄTRACEÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
            ³ ÀÄnumberÄÙ                     ³
            ³              ÚÄNormalÄÄÄÄÄÄÄÄ¿ ³
            ÀÄÂÄÄÄÄÄÄÄÄÄÂÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÙ
              ³ ÚÄÄÄÄÄ¿ ³  ÃÄAllÄÄÄÄÄÄÄÄÄÄÄ´
              ³      ³ ³  ³               ³
              ÀÄÄÄÄ?ÄÄÁÄÙ  ÃÄCommandsÄÄÄÄÄÄ´
                           ÃÄErrorÄÄÄÄÄÄÄÄÄ´
                           ÃÄFailureÄÄÄÄÄÄÄ´
                           ÃÄIntermediatesÄ´
                           ÃÄLabelsÄÄÄÄÄÄÄÄ´
                           ÃÄOffÄÄÄÄÄÄÄÄÄÄÄ´
                           ÀÄResultsÄÄÄÄÄÄÄÙ
 
 Or, alternatively: 
 
 >>ÄÄTRACEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><
            ÃÄstringÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ÃÄsymbolÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ÀÄÂÄÄÄÄÄÄÄÂÄÄexpressionÄÙ
              ÀÄVALUEÄÙ
 
 TRACE controls the tracing action (that is, how much is displayed to the 
 user) during processing of a REXX program. (Tracing describes some or all 
 of the clauses in a program, producing descriptions of clauses as they are 
 processed.) TRACE is mainly used for debugging. Its syntax is more concise 
 than that of other REXX instructions because TRACE is usually entered 
 manually during interactive debugging. (This is a form of tracing in which 
 the user can interact with the language processor while the program is 
 running.) For this use, economy of key strokes is especially convenient. 
 
 If specified, the number must be a whole number. 
 
 The string or expression evaluates to: 
   
   o A numeric option 
   o One of the valid prefix or alphabetic character (word) options 
     described later 
   o Null 
   
 
 The symbol is taken as a constant, and is, therefore: 
   
   o A numeric option 
   o One of the valid prefix or alphabetic character (word) options 
     described later 
   
 
 The option that follows TRACE or the result of evaluating expression 
 determines the tracing action. You can omit the subkeyword VALUE if 
 expression does not begin with a symbol or a literal string (that is, if it 
 starts with a special character, such as an operator or parenthesis). 
 
 Double-click on Alphabetic Character (Word) Options to continue. 



Alphabetic Character (Word) Options
 
 
 Although you can enter the word in full, only the capitalized and 
 highlighted letter is needed; all characters following it are ignored. That 
 is why these are referred to as alphabetic character options. 
 
 TRACE actions correspond to the alphabetic character options as follows: 
 
 All              Traces (that is, displays) all clauses 
                  before execution. 
 Commands         Traces all commands before execution. If 
                  the command results in an error or 
                  failure, then the return code from the 
                  command is also shown. 
 Error            Traces any command resulting in an error 
                  or after execution, together with the 
                  return code from the command. 
 Failure          Traces any command resulting in a failure 
                  after execution, together with the return 
                  code from the command. This is the same 
                  as the Normal option (which is the 
                  default setting). 
 Intermediates    Traces all clauses before execution. Also 
                  traces intermediate results during 
                  evaluation of expressions and substituted 
                  names. 
 Labels           Traces only labels passed during 
                  execution. This is especially useful 
                  while tracing interactively, when the 
                  processor pauses after each label.  It 
                  also helps the user to note all internal 
                  subroutine calls and transfers of control 
                  because of the SIGNAL instruction. 
 Normal           Traces any failing command after 
                  execution, together with the return code 
                  from the command. This is the default 
                  setting. 
                  
                  For the default PC DOS command processor, 
                  an attempt to enter an unknown command 
                  will raise a FAILURE condition. An 
                  attempt to enter a command to an unknown 
                  command environment will also raise a 
                  FAILURE condition; in such a case, the 
                  variable RC is set to 30. 
 Off              Traces nothing and resets the special 
                  prefix option (described later) to OFF. 
 Results          Traces all clauses before execution, 
                  together with the final result of any 
                  expression evaluated.  Also displays 
                  values assigned during PULL, ARG, and 
                  PARSE instructions.  This setting is 
                  recommended for general debugging. 
 
 
 Double-click on Prefix Option to continue. 



Prefix Option
 
 
 The prefix ? is valid either alone or with one of the alphabetic character 
 options. You can specify the prefix more than one time, if desired.  Each 
 occurrence of a prefix on an instruction reverses the action of the 
 previous prefix.  The prefix must immediately precede the option (no 
 intervening blanks). 
 
 The prefix, ?, modifies tracing and execution as follows: 
 
 ?  Controls interactive debug.  During usual execution, a TRACE option 
    with a prefix of ? causes interactive debug to be switched on. While 
    interactive debug is on, interpretation pauses after most clauses 
    that are traced. For example, the instruction TRACE ?E makes the 
    language processor pause for input after executing any command that 
    returns an error (that is, a nonzero return code or explicit setting 
    of the error condition by the command handler). 
    
    Any TRACE instructions in the program being traced are ignored. (This 
    is so that you are not taken out of interactive debug unexpectedly.) 
    
    You can switch off interactive debug in several ways: 
    
    o Entering TRACE O turns off all tracing. 
    o Entering TRACE with no options restores the defaults-it turns off 
      interactive debug but continues tracing with TRACE Normal (which 
      traces any failing command after execution) in effect. 
    o Entering TRACE ? turns off interactive debug and continues 
      tracing with the current option. 
    o Entering a TRACE instruction with a ? prefix before the option 
      turns off interactive debug and continues tracing with the new 
      option. 
    
    Using the ? prefix, therefore, switches you alternately in or out of 
    interactive debug. (Because the language processor ignores any 
    further TRACE statements in your program after you are in interactive 
    debug, use CALL TRACE'?' to turn off interactive debug.) 
 
 
 Double-click on Numeric Options to continue. 



Numeric Options
 
 
 If interactive debug is active and if the option specified is a positive 
 whole number (or an expression that evaluates to a positive whole number), 
 that number indicates the number of debug pauses to be skipped over. 
 However, if the option is a negative whole number (or an expression that 
 evaluates to a negative whole number), all tracing, including debug pauses, 
 is temporarily inhibited for the specified number of clauses.  For example, 
 TRACE -100 means that the next 100 clauses that would usually be traced are 
 not, in fact, displayed.  After that, tracing resumes as before. 
 
 Double-click on Tracing Tips to continue. 



Tracing Tips
 
 
 1.  When a loop is being traced, the DO clause itself is traced on 
     every iteration of the loop. 
 2.  You can retrieve the trace actions currently in effect by using the 
     TRACE built-in function. 
 3.  Comments in the source REXX program are not included in the trace 
     output. 
 4.  Commands traced before execution always have the final value of the 
     command (that is, the string passed to the environment), and the 
     clause generating it produced in the traced output. 
 5.  Trace actions are automatically saved across subroutine and 
     function calls.  See the CALL instruction for more details. 
 
 
 Double-click on A Typical Example to continue. 



A Typical Example
 
 
 One of the most common traces you will use is: 
 
 TRACE ?R
 /* Interactive debug is switched on if it was off, */
 /*  and tracing Results of expressions begins.     */
 
 Double-click on Format of Trace Output to continue. 



Format of TRACE Output
 
 
 Every clause traced appears with automatic formatting (indentation) 
 according to its logical depth of nesting and so forth. Results (if 
 requested) are indented an extra two spaces and are enclosed in double 
 quotation marks so that leading and trailing blanks are apparent. Any 
 control codes in the data encoding (ASCII values less than '20'x) are 
 replaced by a question mark (?) to avoid screen interference. All lines 
 displayed during tracing have a three-character prefix to identify the type 
 of data being traced.  These can be: 
 
 *_*    Identifies the source of a single clause, that is, the data 
        actually in the program. 
 
 +++    Identifies a trace message.  This may be the nonzero return 
        code from a command, the prompt message when interactive 
        debug is entered, an indication of a syntax error when in 
        interactive debug, or the traceback clauses after a syntax 
        error in the program (see below). 
 
 >>>    Identifies the result of an expression (for TRACE R) or the 
        value assigned to a variable during parsing, or the value 
        returned from a subroutine call. 
 
 >.>    Identifies the value "assigned" to a placeholder during 
        parsing. 
 
 
 The following prefixes are used only if TRACE Intermediates is in effect: 
 
 >C>    The data traced is the name of a compound variable, traced 
        after substitution and before use, provided that the name had 
        the value of a variable substituted into it. 
 
 >F>    The data traced is the result of a function call. 
 
 >L>    The data traced is a literal (string, uninitialized variable, 
        or constant symbol). 
 
 >O>    The data traced is the result of an operation on two terms. 
 
 >P>    The data traced is the result of a prefix operation. 
 
 >V>    The data traced is the contents of a variable. 
 
 
 If no option is specified on a TRACE instruction, or if the result of 
 evaluating the expression is null, the default tracing actions are 
 restored.  The defaults are TRACE N and interactive debug (?) off. 



Functions
 
 
 A "function" is an internal, built-in, or external routine that returns a 
 single result string.  See "Quick Reference of REXX Built-In Functions" for 
 a summary of the built-in functions provided by REXX. A "subroutine" is a 
 function that is an internal, built-in, or external routine that may or may 
 not return a result and that is called with the CALL instruction. 
 
 Note: A function can be refrenced either as an expression in an assignment 
 or by the CALL instruction.  If a function is used as an expression, it 
 must return a value.  If a function is referenced by a CALL instruction, 
 any return value is assigned to the special variable RESULT upon return 
 from the called routine. 
 
 Double-click on one of the following topics for more information: 
   
   o Syntax 
   o Functions and Subroutines 
   o Search Order 
   o Errors During Execution 
   o Return Values 
   o Built-in Functions 
   o Quick Reference of REXX Built-In Functions 
   



Syntax
 
 
 A "function call" is a term in an expression that calls a routine that 
 carries out some procedures and returns a string. This string replaces the 
 function call in the continuing evaluation of the expression. You can 
 include function calls to internal and external routines in an expression 
 anywhere that a data term (such as a string) would be valid, using the 
 notation: 
 
                     ÚÄ,ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                     ³
 >>ÄÄfunction_name(ÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÁÄÄ)ÄÄ><
                       ÀÄexpressionÄÙ
 
 The "function_name" is a literal string or a single symbol, which is taken 
 to be a constant. 
 
 There can be up to an implementation-defined maximum number of expressions, 
 separated by commas, between the parentheses. The implementation maximum is 
 up to 20 expressions. These expressions are called the "arguments" to the 
 function. Each argument expression may include further function calls. 
 
 Note that the left parenthesis must be adjacent to the name of the 
 function, with no blank in between, or the construct is not recognized as a 
 function call. (A blank operator would be assumed at this point instead.) 
 Only a comment, (which has no effect), can appear between the name and the 
 left parenthesis. 
 
 The arguments are evaluated in turn from left to right and the resulting 
 strings are all then passed to the function. This then runs some operation 
 (usually dependent on the argument strings passed, though arguments are not 
 mandatory) and eventually returns a single character string. This string is 
 then included in the original expression just as though the entire function 
 reference had been replaced by the name of a variable whose value is that 
 returned data. 
 
 For example, the function SUBSTR is built-in to the language processor and 
 could be used as: 
 
 N1='abcdefghijk'
 Z1='Part of N1 is: 'substr(N1,2,7)
 /* Sets Z1 to 'Part of N1 is: bcdefgh' */
 
 A function may have a variable number of arguments. You need to specify 
 only those that are required. For example, SUBSTR('ABCDEF',4) would return 
 DEF. 



Functions and Subroutines
 
 
 The function calling mechanism is identical with that for subroutines.  The 
 only difference between functions and subroutines is that functions must 
 return data, whereas subroutines need not. 
 
 The following types of routines can be called as functions: 
 
 Internal  If the routine name exists as a label in the program, 
           the current processing status is saved, so that it is 
           later possible to return to the point of invocation to 
           resume execution. Control is then passed to the first 
           label in the program that matches the name. As with a 
           routine called by the CALL instruction, various other 
           status information (TRACE and NUMERIC settings and so 
           forth) is saved too. See the CALL instruction for 
           details about this. You can use SIGNAL and CALL 
           together to call an internal routine whose name is 
           determined at the time of execution; this is known as a 
           multi-way call. 
           
           If you are calling an internal routine as a function, 
           you must specify an expression in any RETURN 
           instruction to return from it.  This is not necessary 
           if it is called as a subroutine. 
 
 Built-in  These functions are always available and are defined in 
           the next section of this manual. (See Built-in 
           Functions.) 
 
 External  You can write or use functions that are external to 
           your program and to the language processor. An external 
           routine can be written in any language (including REXX) 
           that supports the system-dependent interfaces the 
           language processor uses to call it. You can call a REXX 
           program as a function and, in this case, pass more than 
           one argument string. The ARG or PARSE ARG instructions 
           or the ARG built-in function can retrieve these 
           argument strings. When called as a function, a program 
           must return data to the caller. 
           
           Notes: 
    
    1.  Calling an external REXX program as a function is similar to 
        calling an internal routine. The external routine is, 
        however, an implicit PROCEDURE in that all the caller's 
        variables are always hidden and the status of internal values 
        (NUMERIC settings and so forth) start with their defaults 
        (rather than inheriting those of the caller). 
    2.  Other REXX programs can be called as functions. You can use 
        either EXIT or RETURN to leave the called REXX program, and 
        in either case you must specify an expression. 
    3.  With care, you can use the INTERPRET instruction to process a 
        function with a variable function name. However, you should 
        avoid this if possible because it reduces the clarity of the 
        program. 
 



Search Order
 
 
 The search order for functions is: internal routines take precedence, then 
 built-in functions, and finally external functions. 
 
 Internal routines are not used if the function name is given as a literal 
 string (that is, specified in quotation marks); in this case the function 
 must be built-in or external. This lets you override the name of, say, a 
 built-in function to extend its capabilities, yet still be able to call the 
 built-in function when needed. 
 
 Example: 
 
 /* This internal DATE function modifies the          */
 /* default for the DATE function to standard date.   */
 date: procedure
       arg in
       if in='' then in='Standard'
       return 'DATE'(in)
 
 Built-in functions have uppercase names, so the name in the literal string 
 must be in uppercase for the search to succeed, as in the example. File 
 names can be in upper, lower, or mixed case.  PC DOS uses a case 
 insensitive search for files.  When calling a REXX subroutine, the case of 
 the name does not matter. 
 
 External functions and subroutines have a system-defined search order. 
 
 REXX searches for external functions in this order. 
 
 1.  REXX functions in the current directory, with the current 
     extension. 
 2.  REXX functions along environment PATH, with the current extension. 
 3.  REXX functions in the current directory, with the default 
     extension. 
 4.  REXX functions along environment PATH, with the default extension. 
 
 
 Rather than searching for an external function in the order specified 
 above, you can specify a path directly to the function. 
 
 Assuming that the RXCLS.RX external function exists in the C:\DOS 
 directory, the following examples would all run C:\DOS\RXCLS.RX: 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³Example                   ³I, B, or E            ³1, 2, 3 or 4          ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³call RXCLS                ³I, B, and E           ³1, 2, 3, and 4        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³call "RXCLS"              ³B and E               ³1, 2, 3, and 4        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³call "RXCLS.RX"           ³B and E               ³3 and 4               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³call "C:\DOS\RXCLS"       ³B and E               ³Note: Search in the   ³
 ³                          ³                      ³specified path with   ³
 ³                          ³                      ³the current extension,³
 ³                          ³                      ³then the default      ³
 ³                          ³                      ³extension.            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³call "C:\DOS\RXCLS.RX"    ³B and E               ³Note: No search, full ³
 ³                          ³                      ³path is specified.    ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 For example: 
 
     call RXCLS
 
 Determines if RXCLS is an internal (I), a built-in (B), or an external (E) 
 function.  Then it determines which of the four searches (1, 2, 3, or 4) 
 listed above will be performed. 



Errors During Execution
 
 
 If an external or built-in function detects an error of any kind, the 
 language processor is informed, and a syntax error results.  Execution of 
 the clause that included the function call is, therefore, ended. Similarly, 
 if an external function fails to return data correctly, the language 
 processor detects this and reports it as an error. 
 
 If a syntax error occurs during the execution of an internal function, it 
 can be trapped (using SIGNAL ON SYNTAX) and recovery may then be possible. 
 If the error is not trapped, the program is ended. 



Return Values
 
 
 A function usually returns a value that is substituted for the function 
 call when the expression is evaluated. 
 
 How the value returned by a function (or any REXX routine) is handled 
 depends on whether it is called by a function call or as a subroutine with 
 the CALL instruction. 
 
 A routine called as a subroutine: If the routine returns a value, that 
 value is stored in the special variable named RESULT. Otherwise, the RESULT 
 variable is dropped, and its value is the string RESULT. 
 
 A routine called as a function: If the function returns a value, that value 
 is substituted into the expression at the position where the function was 
 called.  Otherwise REXX stops with an error message. 
 



Built-in Functions
 
 
 REXX provides a rich set of built-in functions, including character 
 manipulation, conversion, and information functions. 
 
 The following are general notes on the built-in functions: 
 
 o The parentheses in a function are always needed, even if no arguments 
   are required. The first parenthesis must follow the name of the 
   function with no space in between. 
 o The built-in functions work internally with NUMERIC DIGITS 9 and 
   NUMERIC FUZZ 0 and are unaffected by changes to the NUMERIC settings, 
   except where stated. Any argument named as a number is rounded, if 
   necessary, according to the current setting of NUMERIC DIGITS (just as 
   though the number had been added to 0) and checked for validity before 
   use. This occurs in the following functions: ABS, FORMAT, MAX, MIN, 
   SIGN, and TRUNC, and for certain options of DATATYPE. 
 o Any argument named as a string may be a null string. 
 o If an argument specifies a length, it must be a positive whole number 
   or zero. If it specifies a start character or word in a string, it must 
   be a positive whole number, unless otherwise stated. 
 o Where the last argument is optional, you can always include a comma to 
   indicate you have omitted it; for example, DATATYPE(1,), like 
   DATATYPE(1), would return NUM. 
 o If you specify a pad character, it must be exactly one character long. 
   (A pad character extends a string, usually on the right. For an 
   example, see the LEFT built-in function. 
 o If a function has an option you can select by specifying the first 
   character of a string, that character can be in upper- or lowercase. 
 



Quick Reference of REXX Built-In Functions
 
 
 The following table is a summary of the built-in functions provided by 
 REXX. 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³          REXX Built-In Functions                              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-³
 ³ FUNCTION      ³ ACTION                                        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ABBREV        ³ Indicates whether info is an abbreviation of  ³
 ³               ³ information.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ABS           ³ Returns the absolute value of number.         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ADDRESS       ³ Returns the name of the current environment   ³
 ³               ³ for commands.                                 ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ ARG           ³ Returns the number of arguments, the nth      ³
 ³               ³ argument, or tests if the nth argument        ³
 ³               ³ exists.                                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ BITAND        ³ Returns a string composed of the two input    ³
 ³               ³ strings logically ANDed together, bit by bit. ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ BITOR         ³ Returns a string composed of the two input    ³
 ³               ³ strings logically ORed together, bit by bit.  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ BITXOR        ³ Returns a string composed of the two input    ³
 ³               ³ strings logically exclusive ORed together,    ³
 ³               ³ bit by bit.                                   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-³
 ³ B2X           ³ Binary to Hexadecimal.  Returns a string, in  ³
 ³               ³ character format, that represents             ³
 ³               ³ binary_string converted to hexadecimal.       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CENTER/CENTRE ³ Centers a string.                             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CHARIN        ³ Reads data from an input stream.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CHAROUT       ³ Writes data to an output stream.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CHARS         ³ Indicates if there are more characters avail- ³
 ³               ³ able in an input stream.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ COMPARE       ³ Returns the position of the first character   ³
 ³               ³ where the strings do not match.               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ CONDITION     ³ Returns information associated with the       ³
 ³               ³ current trapped condition.                    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ COPIES        ³ Makes copies of a string.                     ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ C2D           ³ Character to Decimal.  Returns the decimal    ³
 ³               ³ value of the binary representation of string. ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ C2X           ³ Character to Hexadecimal.  Returns the        ³
 ³               ³ hexadecimal representation of string.         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DATATYPE      ³ Determines the data type of a string.         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DATE          ³ Returns the date.                             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DELSTR        ³ Deletes a portion of a string.                ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DELWORD       ³ Deletes words from a string.                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ DIGITS        ³ Returns current setting of NUMERIC DIGITS.    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
 ³ D2C           ³ Decimal to Character.  Returns a character    ³
 ³               ³ string which is the binary representation of  ³
 ³               ³ wholenumber.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ D2X           ³ Decimal to Hexadecimal.  Returns a string     ³
 ³               ³ which is the hexadecimal representation of    ³
 ³               ³ wholenumber.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ ERRORTEXT     ³ Returns error message text.                   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ FORM          ³ Returns the current setting of NUMERIC FORM.  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ FORMAT        ³ Rounds and formats a number.                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ FUZZ          ³ Returns the current setting of NUMERIC FUZZ.  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ INSERT        ³ Inserts one string into another.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LASTPOS       ³ Returns the position of the last occurrence   ³
 ³               ³ of one string in another.                     ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LEFT          ³ Left justifies a string.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LENGTH        ³ Returns the length of a string.               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LINEIN        ³ Reads lines from an input stream.             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LINEOUT       ³ Writes lines to an output stream.             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ LINES         ³ Indicates if there are no more lines avail-   ³
 ³               ³ able in an input stream.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ MAX           ³ Returns the largest number from a specified   ³
 ³               ³ list.                                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ MIN           ³ Returns the smallest number from a specified  ³
 ³               ³ list.                                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ OVERLAY       ³ Overlays one string onto another.             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ POS           ³ Returns the position of one string in         ³
 ³               ³ another.                                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ QUEUED        ³ Returns the number of lines in the program    ³
 ³               ³ stack (system-provided data queue).           ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ RANDOM        ³ Returns a pseudo-random nonnegative whole     ³
 ³               ³ number.                                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ REVERSE       ³ Reverses a string.                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ RIGHT         ³ Right justifies a string.                     ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SIGN          ³ Returns the sign of a number.                 ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SOURCELINE    ³ Returns the line number of the final line in  ³
 ³               ³ the source file or the nth line.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SPACE         ³ Adds spaces between words in a string.        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ STREAM        ³ Returns a string describing the state of, or  ³
 ³               ³ the result of an operation upon, the char-    ³
 ³               ³ acter stream name.                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ STRIP         ³ Removes leading or trailing characters from a ³
 ³               ³ string.                                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SUBSTR        ³ Returns a string of characters taken from     ³
 ³               ³ another string.                               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SUBWORD       ³ Returns a string of words taken from another  ³
 ³               ³ string.                                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ SYMBOL        ³ Determines if name is a symbol or a variable. ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ TIME          ³ Returns the local time.                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-´
 ³ TRACE         ³ Returns the current trace setting or sets a   ³
 ³               ³ new trace option.                             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ TRANSLATE     ³ Translates characters in a string.            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ TRUNC         ³ Returns the integer part of a number and n    ³
 ³               ³  decimal places.                              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ VALUE         ³ Returns the value of the symbol name, and     ³
 ³               ³ sets a new value.                             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ VERIFY        ³ Verifies that one string is in another.       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ WORD          ³ Returns a blank-delimited word from a string. ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ WORDINDEX     ³ Returns the position of a blank-delimited     ³
 ³               ³ word in a string.                             ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ WORDLENGTH    ³ Returns the length of a blank-delimited word  ³
 ³               ³ in a string.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ WORDPOS       ³ Returns the position of a phrase in a string. ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ WORDS         ³ Returns the number of blank-delimited words   ³
 ³               ³ in a string.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ XRANGE        ³ Returns a string of one-byte codes.           ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ X2B           ³ Hexadecimal to Binary.  Converts a            ³
 ³               ³ hexadecimal string to binary.                 ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ X2C           ³ Hexadecimal to Character.  Converts a         ³
 ³               ³ hexadecimal string to character.              ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³ X2D           ³ Hexadecimal to Decimal.  Converts a           ³
 ³               ³ hexadecimal string to a decimal number.       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 



ABBREV (Abbreviation)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄABBREV(information,infoÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                              ÀÄ,lengthÄÙ                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns 1 if info is equal to the leading characters of information and the 
 length of info is not less than length. Returns 0 if either of these 
 conditions is not met. 
 
 If you specify length, it must be a positive whole number or zero. The 
 default for length is the number of characters in info. 
 
 Examples: 
 
 ABBREV('Print','Pri')      ->    1
 ABBREV('PRINT','Pri')      ->    0
 ABBREV('PRINT','PRI',4)    ->    0
 
 Note: A null string always matches if a length of 0 (or the default) is 
 used. This allows a default keyword to be selected automatically if 
 desired. For example: 
 
 say 'Enter option:';   pull option .
 select  /* keyword1 is to be the default */
   when abbrev('keyword1',option) then ...
   when abbrev('keyword2',option) then ...
   ...
   otherwise nop;
 end;
 
 



ABS (Absolute Value)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄABS(number)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the absolute value of number. The result has no sign and is 
 formatted according to the current NUMERIC settings. 
 
 Examples: 
 
 ABS('12.3')       ->    12.3
 ABS(' -0.307')    ->    0.307
 
 



ADDRESS
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄADDRESS()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the name of the environment to which commands are currently being 
 submitted. See the ADDRESS instruction for more information. Trailing 
 blanks are removed from the result. 
 
 Examples: 
 
 ADDRESS()    ->    'COMMAND'        /* default under PC DOS    */
 ADDRESS()    ->    'EDIT'           /* possible editor         */
 
 



ARG (Argument)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄARG(ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³           ÀÄnÄÄÂÄÄÄÄÄÄÄÄÄÂÄÙ                                          ³
 ³                ÀÄ,optionÄÙ                                            ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns an argument string or information about the argument strings to a 
 program or internal routine. 
 
 If you do not specify n, the number of arguments passed to the program or 
 internal routine is returned. 
 
 If you specify only n, the nth argument string is returned. If the argument 
 string does not exist, the null string is returned. The n must be a 
 positive whole number. 
 
 If you specify option, ARG tests for the existence of the nth argument 
 string. The following are valid options. (Only the capitalized and 
 highlighted letter is needed; all characters following it are ignored.) 
 
 Exists   returns 1 if the nth argument exists; that is, if it was 
          explicitly specified when the routine was called. Returns 
          0 otherwise. 
 Omitted  returns 1 if the nth argument was omitted; that is, if it 
          was not explicitly specified when the routine was called. 
          Returns 0 otherwise. 
 
 
 Examples: 
 
 /*  following "Call name"; (no arguments) */
 ARG()         ->    0
 ARG(1)        ->    ''
 ARG(1,'e')    ->    0
 ARG(1,'O')    ->    1
 
 /*  following "Call name 'a',,'b';" */
 ARG()         ->    3
 ARG(1)        ->    'a'
 ARG(2)        ->    ''
 ARG(3)        ->    'b'
 ARG(n)        ->    ''    /* for n>=4 */
 ARG(1,'e')    ->    1
 ARG(2,'E')    ->    0
 ARG(2,'O')    ->    1
 ARG(3,'o')    ->    0
 ARG(4,'o')    ->    1
 
 Notes: 
 
 1.  The number of argument strings is the largest number n for which 
     ARG(n,'e') would return 1 or 0 if there are no explicit argument 
     strings. That is, it is the position of the last explicitly 
     specified argument string. 
 2.  Programs called as commands can have only 0 or 1 argument strings. 
     The program has 0 argument strings if it is called with the name 
     only and has 1 argument string if anything else (including blanks) 
     is included with the command. 
 3.  You can retrieve and directly parse the argument strings to a 
     program or internal routine with the ARG or PARSE ARG instructions. 
 



BITAND (Bit by Bit AND)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄBITAND(string1ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                     ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ                      ³
 ³                          ÀÄstring2ÄÙ  ÀÄ,padÄÙ                        ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string composed of the two input strings logically ANDed 
 together, bit by bit. (The encodings of the strings are used in the logical 
 operation.) The length of the result is the length of the longer of the two 
 strings. If no pad character is provided, the AND operation stops when the 
 shorter of the two strings is exhausted, and the unprocessed portion of the 
 longer string is appended to the partial result.  If pad is provided, it 
 extends the shorter of the two strings on the right before carrying out the 
 logical operation. The default for string2 is the zero length (null) 
 string. 
 
 Examples: 
 
 BITAND('12'x)                  ->    '12'x
 BITAND('73'x,'27'x)            ->    '23'x
 BITAND('13'x,'5555'x)          ->    '1155'x
 BITAND('pQrS',,'DF'x)          ->    'PQRS'      /* ASCII   */
 
 



BITOR (Bit by Bit OR)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄBITOR(string1ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                    ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ                       ³
 ³                         ÀÄstring2ÄÙ  ÀÄ,padÄÙ                         ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string composed of the two input strings logically inclusive-ORed 
 together, bit by bit. (The encodings of the strings are used in the logical 
 operation.) The length of the result is the length of the longer of the two 
 strings. If no pad character is provided, the OR operation stops when the 
 shorter of the two strings is exhausted, and the unprocessed portion of the 
 longer string is appended to the partial result.  If pad is provided, it 
 extends the shorter of the two strings on the right before carrying out the 
 logical operation. The default for string2 is the zero length (null) 
 string. 
 
 Examples: 
 
 BITOR('12'x)                  ->    '12'x
 BITOR('15'x,'24'x)            ->    '35'x
 BITOR('15'x,'2456'x,'F0'x)    ->    '35F6'x
 BITOR('1111'x,,'4D'x)         ->    '5D5D'x
 BITOR('pQrS',,'20'x)          ->    'pqrs' /* ASCII   */
 
 



BITXOR (Bit by Bit Exclusive OR)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄBITXOR(string1ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                     ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ                      ³
 ³                          ÀÄstring2ÄÙ  ÀÄ,padÄÙ                        ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string composed of the two input strings logically 
 eXclusive-ORed together, bit by bit. (The encodings of the strings are used 
 in the logical operation.) The length of the result is the length of the 
 longer of the two strings. If no pad character is provided, the XOR 
 operation stops when the shorter of the two strings is exhausted, and the 
 unprocessed portion of the longer string is appended to the partial result. 
 If pad is provided, it extends the shorter of the two strings on the right 
 before carrying out the logical operation. The default for string2 is the 
 zero length (null) string. 
 
 Examples: 
 
 BITXOR('12'x)                     ->  '12'x
 BITXOR('1211'x,'22'x)             ->  '3011'x
 BITXOR('1111'x,'444444'x)         ->  '555544'x
 BITXOR('1111'x,'444444'x,'40'x)   ->  '555504'x
 BITXOR('1111'x,,'4D'x)            ->  '5C5C'x
 BITXOR('C711'x,'222222'x,' ')     ->  'E53302'x  /* ASCII  */
 
 



B2X (Binary to Hexadecimal)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄB2X(binary_string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that represents binary_string 
 converted to hexadecimal. 
 
 The binary_string is a string of binary (0 or 1) digits. It can be of any 
 length. You can optionally include blanks in binary_string (at four-digit 
 boundaries only, not leading or trailing) to aid readability; they are 
 ignored. 
 
 The returned string uses uppercase alphabetics for the values A-F, and does 
 not include blanks. 
 
 If binary_string is the null string, B2X returns a null string. If the 
 number of binary digits in binary_string is not a multiple of four, then up 
 to three 0 digits are added on the left before the conversion to make a 
 total that is a multiple of four. 
 
 Examples: 
 
 B2X('11000011')    ->   'C3'
 B2X('10111')       ->   '17'
 B2X('101')         ->   '5'
 B2X('1 1111 0000') ->   '1F0'
 
 You can combine B2X with the functions X2D and X2C to convert a binary 
 number into other forms. For example: 
 
 X2D(B2X('10111'))  ->   '23'   /* decimal 23 */
 
 



CENTER/CENTRE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄÂÄCENTER(ÄÂÄÄstring,lengthÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³     ÀÄCENTRE(ÄÙ                 ÀÄ,padÄÙ                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string of length length with string centered in it, with pad 
 characters added as necessary to make up length. The length must be a 
 positive whole number or zero. The default pad character is blank. If the 
 string is longer than length, it is truncated at both ends to fit. If an 
 odd number of characters are truncated or added, the right-hand end loses 
 or gains one more character than the left-hand end. 
 
 Examples: 
 
 CENTER(abc,7)               ->    '  ABC  '
 CENTER(abc,8,'-')           ->    '--ABC---'
 
 Note: To avoid errors because of the difference between British and 
 American spellings, this function can be called either CENTRE or CENTER. 



CHARIN (Character Input)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                        ³
 ³ >>ÄÄCHARIN(ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÀÄnameÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÂÄÙ                   ³
 ³                             ÀÄstartÄÙ  ÀÄ,lengthÄÙ                     ³
 ³                                                                        ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string of up to length characters read from the character input 
 stream name. If you omit name, characters are read from the device named 
 STDIN (generally the keyboard), which is the default input stream. The 
 default length is 1. 
 
 For persistent streams (a static form, such as a file or data object), a 
 read position is maintained for each stream. In PC DOS, this is the same as 
 the write position. Any read from the stream starts at the current read 
 position by default. When the language processor completes reading, the 
 read position is increased by the number of characters read. You can give a 
 start value to specify an explicit read position.  This read position must 
 be positive and within the bounds of the stream, and must not be specified 
 for a transient stream. A value of 1 for start refers to the first 
 character in the stream. 
 
 If you specify a length of 0, then the read position is set to the value of 
 start but no characters are read and the null string is returned. 
 
 In a transient stream (dynamic, such as data sent or recieved over a serial 
 interface), if there are fewer than length characters available, then 
 execution of the program generally stops until sufficient characters do 
 become available.  If, however, it is impossible for those characters to 
 become available because of an error or other problem, the NOTREADY 
 condition is raised and CHARIN returns with fewer than the requested number 
 of characters. 
 
 Examples: 
 
 CHARIN(myfile,1,3)   ->   'MFC'    /* the first 3      */
                                    /* characters       */
 CHARIN(myfile,1,0)   ->   ''       /* now at start     */
 CHARIN(myfile)       ->   'M'      /* after last call  */
 CHARIN(myfile,,2)    ->   'FC'     /* after last call  */
 
 /* Reading from the default input (here, the keyboard) */
 /* User types 'abcd efg'                               */
 CHARIN()             ->   'a'      /* default is       */
                                    /* 1 character      */
 CHARIN(,,5)          ->   'bcd e'
 
 Notes: 
 
 1.  CHARIN returns all characters that appear in the stream, including 
     control characters such as line feed, carriage return, and end of 
     file. 
 2.  When CHARIN reads from the keyboard, program execution stops until 
     you press the Enter key. 
 3.  When using default stream an extra carriage return is added by REXX 
     to allow for the display of echo data. 
 4.  Normal line-by-line dialogue with the user should be carried out 
     with the PULL or PARSE PULL instructions, to maintain generality 
     and programmability. 
 



CHAROUT (Character Output)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                        ³
 ³ >>ÄÄCHAROUT(ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³               ÀÄnameÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÂÄÙ                  ³
 ³                              ÀÄstringÄÙ  ÀÄ,startÄÙ                    ³
 ³                                                                        ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the count of characters remaining after attempting to write string 
 to the character output stream name. If you omit name, characters in string 
 are written to the device STDOUT (generally the display), which is the 
 default output stream. The string can be the null string, in which case no 
 characters are written to the stream, and 0 is always returned. 
 
 For persistent streams, a write position is maintained for each stream. In 
 PC DOS, this is the same as the read position. Any write to the stream 
 starts at the current write position by default. When the language 
 processor completes writing, the write position is increased by the number 
 of characters written. When the stream is first opened, the write position 
 is at the end of the stream so that calls to CHAROUT will append characters 
 to the end of the stream. 
 
 You can give a start value to specify an explicit write position for a 
 persistent stream. This write position must be a positive whole number 
 within the bounds of the stream (though it can specify the character 
 position immediately after the end of the stream). A value of 1 for start 
 refers to the first character in the stream. 
 
 You can omit the string for persistent streams. In this case, the write 
 position is set to the value of start that was given, no characters are 
 written to the stream, and 0 is returned. If you do not specify start or 
 string, the stream is closed. Again, 0 is returned. 
 
 Execution of the program usually stops until the output operation is 
 effectively complete. 
 
 For example, when data is sent to a printer, the system accepts the data 
 and returns control to REXX, even though the output data may not have been 
 printed on the printer.  REXX considers this to be complete, even though 
 the data has not been printed. If, however, it is impossible for all the 
 characters to be written, the NOTREADY condition is raised and CHAROUT 
 returns with the number of characters that could not be written (the 
 residual count). 
 
 Examples: 
 
 CHAROUT(myfile,'Hi')     ->   0   /* typically        */
 CHAROUT(myfile,'Hi',5)   ->   0   /* typically        */
 CHAROUT(myfile,,6)       ->   0   /* now at char 6    */
 CHAROUT(myfile)          ->   0   /* at end of stream */
 CHAROUT(,'Hi')           ->   0   /* typically        */
 CHAROUT(,'Hello')        ->   2   /* maybe            */
 
 Note: This routine is often best called as a subroutine. The residual count 
 is then available in the variable RESULT. 
 
 For example: 
 
 Call CHAROUT myfile,'Hello'
 Call CHAROUT myfile,'Hi',6
 Call CHAROUT myfile
 
 



CHARS (Characters Remaining)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                        ³
 ³ >>ÄÄCHARS(ÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³             ÀÄnameÄÙ                                                   ³
 ³                                                                        ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the total number of characters remaining in the character input 
 stream name. The count includes any line separator characters, if these are 
 defined for the stream. In the case of persistent streams, it is the count 
 of characters from the current read position. If you omit name, the number 
 of characters available in the default input stream (STDIN) is returned. 
 
 For some streams the total number of characters cannot be determined, 
 therefore. the CHARS function returns 1 to indicate that data is present, 
 or 0 if no data is present. 
 
 Examples: 
 
 CHARS(myfile)     ->   42   /* perhaps */
 CHARS(nonfile)    ->   0    /* perhaps */
 CHARS()           ->   1    /* perhaps */
 
 



COMPARE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                        ³
 ³ >>ÄÄCOMPARE(string1,string2ÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                              ÀÄ,padÄÙ                                  ³
 ³                                                                        ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns 0 if the strings, string1 and string2, are identical. Otherwise, 
 returns the position of the first character that does not match. The 
 shorter string is padded on the right with pad if necessary.  The default 
 pad character is a blank. 
 
 Examples: 
 
 COMPARE('abc','abc')         ->    0
 COMPARE('abc','ak')          ->    2
 COMPARE('ab ','ab')          ->    0
 COMPARE('ab ','ab',' ')      ->    0
 COMPARE('ab ','ab','x')      ->    3
 COMPARE('ab-- ','ab','-')    ->    5
 
 



CONDITION
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                        ³
 ³ >>ÄÄCONDITION(ÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                 ÀÄoptionÄÙ                                             ³
 ³                                                                        ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the condition information associated with the current trapped 
 condition. You can request the following pieces of information: 
 
 o The name of the current trapped condition 
 o Any descriptive string associated with that condition 
 o The instruction processed as a result of the condition trap (CALL or 
   SIGNAL) 
 o The status of the trapped condition 
 
 
 To select the information to return, use the following options. (Only the 
 capitalized and highlighted letter is needed; all characters following it 
 are ignored.) 
 
 Condition name    returns the name of the current trapped 
                   condition. 
 Description       returns any descriptive string 
                   associated with the current trapped 
                   condition. If no description is 
                   available, returns a null string. 
 Instruction       returns either CALL or SIGNAL, the 
                   keyword for the instruction processed 
                   when the current condition was trapped. 
                   This is the default if you omit option. 
 Status            returns the status of the current 
                   trapped condition.  This can change 
                   during processing, and is either: 
    
    ON - the condition is enabled 
    
    OFF - the condition is disabled 
    
    DELAY - any new occurrence of the condition is delayed or ignored. 
 
 
 If no condition has been trapped then the CONDITION function returns a null 
 string in all four cases. 
 
 Examples: 
 
 CONDITION()            ->    'CALL'        /* perhaps */
 CONDITION('C')         ->    'FAILURE'
 CONDITION('I')         ->    'CALL'
 CONDITION('D')         ->    'FailureTest'
 CONDITION('S')         ->    'OFF'        /* perhaps */
 
 Note: The CONDITION function returns condition information that is saved 
 and restored across subroutine calls (including those a CALL ON condition 
 trap causes). Therefore, after a subroutine called with CALL ON trapname 
 has returned, the current trapped condition reverts to the condition that 
 was current before the CALL took place (which may be none). CONDITION 
 returns the values it returned before the condition was trapped. 



COPIES
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄCOPIES(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns n concatenated copies of string. The n must be a positive whole 
 number or zero. 
 
 Examples: 
 
 COPIES('abc',3)    ->    'abcabcabc'
 COPIES('abc',0)    ->    ''
 
 



C2D (Character to Decimal)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄC2D(stringÄÄÂÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                 ÀÄ,nÄÙ                                                ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the decimal value of the binary representation of string. If the 
 result cannot be expressed as a whole number, an error results. That is, 
 the result must not have more digits than the current setting of NUMERIC 
 DIGITS. If you specify n, it is the length of the returned result. If you 
 do not specify n, string is processed as an unsigned binary number. 
 
 If string is null, returns 0. 
 
 Examples: 
 
 C2D('09'X)      ->        9
 C2D('81'X)      ->      129
 C2D('FF81'X)    ->    65409
 C2D('')         ->        0
 C2D('a')        ->       97     /*  ASCII   */
 
 If you specify n, the string is taken as a signed number expressed in n 
 characters. The number is positive if the leftmost bit is off, and 
 negative, in two's complement notation, if the leftmost bit is on. In both 
 cases, it is converted to a whole number, which may, therefore, be 
 negative. The string is padded on the left with '00'x characters (note, not 
 "sign-extended"), or truncated on the left to n characters. This padding or 
 truncation is as though RIGHT(string,n,'00'x) had been processed. If n is 
 0, C2D always returns 0. 
 
 Examples: 
 
 C2D('81'X,1)      ->     -127
 C2D('81'X,2)      ->      129
 C2D('FF81'X,2)    ->     -127
 C2D('FF81'X,1)    ->     -127
 C2D('FF7F'X,1)    ->      127
 C2D('F081'X,2)    ->    -3967
 C2D('F081'X,1)    ->     -127
 C2D('0031'X,0)    ->        0
 
 Implementation maximum: The input string cannot have more than 250 
 characters that are significant in forming the final result.  Leading sign 
 characters ('00'x and 'FF'x) do not count toward this total. 



C2X (Character to Hexadecimal)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄC2X(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that represents string converted to 
 hexadecimal. The returned string contains twice as many bytes as the input 
 string. On an ASCII system, C2X(1) returns 31 because the ASCII 
 representation of the character 1 is '31'X. 
 
 The string returned uses uppercase alphabetics for the values A-F and does 
 not include blanks. The string can be of any length. If string is null, 
 returns a null string. 
 
 Examples: 
 
 C2X('0123'X)    ->    '0123'   /* '30313233'X     in ASCII */
 C2X('ZD8')      ->    '5A4438' /* '354134343338'X in ASCII */
 
 



DATATYPE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄDATATYPE(stringÄÄÂÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                      ÀÄ,typeÄÙ                                        ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns NUM if you specify only string and if string is a valid REXX number 
 that can be added to 0 without error; returns CHAR if string is not a valid 
 number. 
 
 If you specify type, returns 1 if string matches the type; otherwise 
 returns 0. If string is null, the function returns 0 (except when type is 
 X, which returns 1 for a null string). The following are valid types. (Only 
 the capitalized and highlighted letter is needed; all characters following 
 it are ignored. Note that for the hexadecimal option, you must start your 
 string specifying the name of the option with x rather than h.) 
 
 Alphanumeric   returns 1 if string contains only characters 
                from the ranges a-z, A-Z, and 0-9. 
 Binary         returns 1 if string contains only the 
                characters 0 or 1 or both. 
 Lowercase      returns 1 if string contains only characters 
                from the range a-z. 
 Mixed case     returns 1 if string contains only characters 
                from the ranges a-z and A-Z. 
 Number         returns 1 if DATATYPE(string) would return 
                NUM. 
 Symbol         returns 1 if string is a valid symbol, that 
                is if SYMBOL(string) would not return BAD.  
                Note that both uppercase and lowercase 
                alphabetics are permitted. 
 Uppercase      returns 1 if string contains only characters 
                from the range A-Z. 
 Whole number   returns 1 if string is a REXX whole number 
                under the current setting of NUMERIC DIGITS. 
 heXadecimal    returns 1 if string contains only characters 
                from the ranges a-f, A-F, 0-9, and blank (as 
                long as blanks appear only between pairs of 
                hexadecimal characters). Also returns 1 if 
                string is a null string, which is a valid 
                hexadecimal string. 
 Examples: 
 
 DATATYPE(' 12 ')         ->   'NUM'
 DATATYPE('')             ->   'CHAR'
 DATATYPE('123*')         ->   'CHAR'
 DATATYPE('12.3','N')     ->    1
 DATATYPE('Fred','M')     ->    1
 DATATYPE('','M')         ->    0
 DATATYPE('Fred','L')     ->    0
 DATATYPE('?20K','s')     ->    1
 DATATYPE('BC d3','X')    ->    1
 
 Note: The DATATYPE function tests the meaning or type of characters in a 
 string, independent of the encoding of those characters (for example, ASCII 
 or EBCDIC). 



DATE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄDATE(ÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³            ÀÄoptionÄÙ                                                 ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns, by default, the local date in the format: dd mon yyyy (day month 
 year-for example, 11 Nov 1994), with no leading zero or blank on the day. 
 The first three characters of the English name of the month are used. 
 
 You can use the following options to obtain specific formats. (Only the 
 capitalized and highlighted letter is needed; all characters following it 
 are ignored.) 
 
 Base        returns the number of complete days (that is, not 
             including the current day) since and including the 
             base date, 1 January 0001, in the format: dddddd 
             (no leading zeros or blanks). The expression 
             DATE('B')//7 returns a number in the range 0-6, 
             where 0 is Monday and 6 is Sunday. 
             
             Note: The base date of 1 January 0001 is determined 
             by extending the current Gregorian calendar 
             backward (365 days each year, with an extra day 
             every year that is divisible by 4 except century 
             years that are not divisible by 400). It does not 
             take into account any errors in the calendar system 
             that created the Gregorian calendar originally. 
 Days        returns the number of days, including the current 
             day, so far in this year in the format: ddd (no 
             leading zeros or blanks). 
 European    returns date in the format: dd/mm/yy. 
 Language    returns date in an implementation- and 
             language-dependent, or local, date format. The 
             Language format is dd Month yyyy. The name of the 
             month will be according to the national language 
             installed on the system. If no local date format is 
             available, the default format is returned. 
             
             Note: This format is intended to be used as a 
             whole; REXX programs should not make any 
             assumptions about the form or content of the 
             returned string. 
 Month       returns full English name of the current month, for 
             example, August. 
 Normal      returns date in the format: dd mon yyyy. This is 
             the default. 
 Ordered     returns date in the format: yy/mm/dd (suitable for 
             sorting, and so forth). 
 Standard    returns date in the format: yyyymmdd (suitable for 
             sorting, and so forth). 
 Usa         returns date in the format: mm/dd/yy. 
 Weekday     returns the English name for the day of the week, 
             in mixed case, for example, Tuesday. 
 
 
 Here are some examples, assuming today is 11 November 1994: 
 
 DATE()         ->    '11 Nov 1994'
 DATE('B')      ->    728342
 DATE('D')      ->    315
 DATE('E')      ->    '11/11/94'
 DATE('L')      ->    '11 November 1994'
 DATE('M')      ->    'November'
 DATE('N')      ->    '11 Nov 1994'
 DATE('O')      ->    '94/11/11'
 DATE('S')      ->    '19941111'
 DATE('U')      ->    '11/11/94'
 DATE('W')      ->    'Friday'
 
 Note: The first call to DATE or TIME in one clause causes a time stamp to 
 be made that is then used for "all" calls to these functions in that 
 clause. Therefore, multiple calls to any of the DATE or TIME functions or 
 both in a single expression or clause are guaranteed to be consistent with 
 each other. 



DELSTR (Delete String)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄDELSTR(string,nÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                      ÀÄ,lengthÄÙ                                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns string after deleting the substring that begins at the nth 
 character and is of length characters. If you omit length, or if length is 
 greater than the number of characters from n to the end of string, the 
 function deletes the rest of string (including the nth character). The 
 length must be a positive whole number or zero. The n must be a positive 
 whole number. If n is greater than the length of string, the function 
 returns string unchanged. 
 
 Examples: 
 
 DELSTR('abcd',3)       ->    'ab'
 DELSTR('abcde',3,2)    ->    'abe'
 DELSTR('abcde',6)      ->    'abcde'
 
 



DELWORD (Delete Word)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄDELWORD(string,nÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                       ÀÄ,lengthÄÙ                                     ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns string after deleting the substring that starts at the nth word and 
 is of length blank-delimited words. If you omit length, or if length is 
 greater than the number of words from n to the end of string, the function 
 deletes the remaining words in string (including the nth word). The length 
 must be a positive whole number or zero. The n must be a positive whole 
 number. If n is greater than the number of words in string, the function 
 returns string unchanged. The string deleted includes any blanks following 
 the final word involved but none of the blanks preceding the first word 
 involved. 
 
 Examples: 
 
 DELWORD('Now is the  time',2,2)  ->  'Now time'
 DELWORD('Now is the time ',3)    ->  'Now is '
 DELWORD('Now is the  time',5)    ->  'Now is the  time'
 DELWORD('Now is   the time',3,1) ->  'Now is   time'
 
 



DIGITS
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄDIGITS()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the current setting of NUMERIC DIGITS. 
 
 Example: 
 
 DIGITS()    ->    9      /* by default */
 
 



D2C (Decimal to Character)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄD2C(wholenumberÄÄÂÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                      ÀÄ,nÄÙ                                           ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that is the ASCII representation of 
 the decimal number. If you specify n, it is the length of the final result 
 in characters. 
 
 Examples: 
 
 D2C(65)      ->   'A'      /* '41'x is an ASCII 'A'    */
 D2C(65,1)    ->   'A'
 D2C(109)     ->   'm'      /* '6D'x  is an ASCII 'm'   */
 D2C(-109,1)  ->   ''      /* '93'x is an ASCII ''    */
 D2C(76,2)    ->   ' L'     /* '4C'x  is an ASCII ' L'  */
 D2C(-180,2)  ->   ' L'
 
 Implementation maximum: The output string may not have more than 250 
 significant characters, though a longer result is possible if it has 
 additional leading sign characters ('00'x and 'FF'x). 



D2X (Decimal to Hexadecimal)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄD2X(wholenumberÄÄÂÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                      ÀÄ,nÄÙ                                           ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that represents wholenumber, a 
 decimal number, converted to hexadecimal. The returned string uses 
 uppercase alphabetics for the values A-F and does not include blanks. 
 
 If you specify n, it is the length of the final result in characters; after 
 conversion the input string is sign-extended to the required length. If the 
 number is too big to fit into n characters, it is truncated on the left. 
 The n must be a positive whole number or zero. 
 
 If you omit n, wholenumber must be a positive whole number or zero, and the 
 returned result has no leading zeros. 
 
 Examples: 
 
 D2X(9)         ->    '9'
 D2X(129)       ->    '81'
 D2X(129,1)     ->    '1'
 D2X(129,2)     ->    '81'
 D2X(129,4)     ->    '0081'
 D2X(257,2)     ->    '01'
 D2X(-127,2)    ->    '81'
 D2X(-127,4)    ->    'FF81'
 D2X(12,0)      ->    ''
 
 Implementation maximum: The output string may not have more than 500 
 significant hexadecimal characters, though a longer result is possible if 
 it has additional leading sign characters (0 and F). 



ERRORTEXT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄERRORTEXT(n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the REXX error message associated with error number n. The n must 
 be in the range 0-99, and any other value is an error. Returns the null 
 string if n is in the allowed range but is not a defined REXX error number. 
 
 Examples: 
 
 ERRORTEXT(16)    ->    'Label not found'
 ERRORTEXT(60)    ->    ''
 
 



FORM
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄFORM()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the current setting of NUMERIC FORM. 
 
 Example: 
 
 FORM()    ->    'SCIENTIFIC'  /* by default */
 
 



FORMAT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                          ³
 ³ >>ÄÄFORMAT(numberÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ> ³
 ³                                                                          ³
 ³ >ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)Ä>< ³
 ³    ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ       ³
 ³         ÀÄbeforeÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ         ³
 ³                          ÀÄafterÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÙ           ³
 ³                                          ÀÄexppÄÙ  ÀÄ,exptÄÙ             ³
 ³                                                                          ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns number, rounded and formatted. 
 
 The number is first rounded according to standard REXX rules, just as 
 though the operation number+0 had been carried out. The result is precisely 
 that of this operation if you specify only number. If you specify any other 
 options, the number is formatted as follows. 
 
 The before and after options describe how many characters are used for the 
 integer and decimal parts of the result, respectively. If you omit either 
 or both of these, the number of characters used for that part is as needed. 
 
 If before is not large enough to contain the integer part of the number 
 (plus the sign for a negative number), an error results. If before is 
 larger than needed for that part, the number is padded on the left with 
 blanks. If after is not the same size as the decimal part of the number, 
 the number is rounded (or extended with zeros) to fit. Specifying 0 causes 
 the number to be rounded to an integer. 
 
 Examples: 
 
 FORMAT('3',4)            ->    '   3'
 FORMAT('1.73',4,0)       ->    '   2'
 FORMAT('1.73',4,3)       ->    '   1.730'
 FORMAT('-.76',4,1)       ->    '  -0.8'
 FORMAT('3.03',4)         ->    '   3.03'
 FORMAT(' - 12.73',,4)    ->    '-12.7300'
 FORMAT(' - 12.73')       ->    '-12.73'
 FORMAT('0.000')          ->    '0'
 
 The first three arguments are as described previously.  In addition, expp 
 and expt control the exponent part of the result, which, by default, is 
 formatted according to the current NUMERIC settings of DIGITS and FORM. The 
 expp sets the number of places for the exponent part; the default is to use 
 as many as needed (which may be zero). The expt sets the trigger point for 
 use of exponential notation. The default is the current setting of NUMERIC 
 DIGITS. 
 
 If expp is 0, no exponent is supplied, and the number is expressed in 
 simple form with added zeros as necessary. If expp is not large enough to 
 contain the exponent, an error results. 
 
 If the number of places needed for the integer or decimal part exceeds expt 
 or twice expt, respectively, exponential notation is used. If expt is 0, 
 exponential notation is always used unless the exponent would be 0. (If 
 expp is 0, this overrides a 0 value of expt.) If the exponent would be 0 
 when a nonzero expp is specified, then expp+2 blanks are supplied for the 
 exponent part of the result. If the exponent would be 0 and expp is not 
 specified, simple form is used. 
 
 Examples: 
 
 FORMAT('12345.73',,,2,2)    ->    '1.234573E+04'
 FORMAT('12345.73',,3,,0)    ->    '1.235E+4'
 FORMAT('1.234573',,3,,0)    ->    '1.235'
 FORMAT('12345.73',,,3,6)    ->    '12345.73'
 FORMAT('1234567e5',,3,0)    ->    '123456700000.000'
 
 



FUZZ
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄFUZZ()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the current setting of NUMERIC FUZZ. 
 
 Example: 
 
 FUZZ()    ->    0     /* by default */
 
 



INSERT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                          ³
 ³ >>ÄÄINSERT(new,targetÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄ>< ³
 ³                        ÀÄ,ÄÄÂÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ         ³
 ³                             ÀÄnÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ           ³
 ³                                         ÀÄlengthÄÙ  ÀÄ,padÄÙ             ³
 ³                                                                          ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 inserts the string new, padded or truncated to length length, into the 
 string target after the nth character. The default value for n is 0, which 
 means insert before the beginning of the string. If specified, n and length 
 must be positive whole numbers or zero. If n is greater than the length of 
 the target string, padding is added before the string new also. The default 
 value for length is the length of new. If length is less than the length of 
 the string new, then INSERT truncates new to length length.  The default 
 pad character is a blank. 
 
 Examples: 
 
 INSERT(' ','abcdef',3)         ->    'abc def'
 INSERT('123','abc',5,6)        ->    'abc  123   '
 INSERT('123','abc',5,6,'+')    ->    'abc++123+++'
 
 



LASTPOS (Last Position)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLASTPOS(needle,haystackÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                              ÀÄ,startÄÙ                               ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the position of the last occurrence of one string, needle, in 
 another, haystack. (See also the POS function.) Returns 0 if needle is the 
 null string or is not found. By default the search starts at the last 
 character of haystack and scans backward. You can override this by 
 specifying start, the point at which the backward scan starts. start must 
 be a positive whole number and defaults to LENGTH(haystack) if larger than 
 that value or omitted. 
 
 Examples: 
 
 LASTPOS(' ','abc def ghi')      ->    8
 LASTPOS(' ','abcdefghi')        ->    0
 LASTPOS('xy','efgxyz')          ->    4
 LASTPOS(' ','abc def ghi',7)    ->    4
 
 



LEFT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLEFT(string,lengthÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                         ÀÄ,padÄÙ                                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string of length length, containing the leftmost length 
 characters of string. The string returned is padded with pad characters (or 
 truncated) on the right as needed. The default pad character is a blank. 
 length must be a positive whole number or zero. The LEFT function is 
 exactly equivalent to: 
 
 >>ÄÄSUBSTR(string,1,lengthÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄ><
                             ÀÄ,padÄÙ
 
 Examples: 
 
 LEFT('abc d',8)        ->    'abc d   '
 LEFT('abc d',8,'.')    ->    'abc d...'
 LEFT('abc  def',7)     ->    'abc  de'
 
 



LENGTH
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLENGTH(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the length of string. 
 
 Examples: 
 
 LENGTH('abcdefgh')    ->    8
 LENGTH('abc defg')    ->    8
 LENGTH('')            ->    0
 
 



LINEIN (Line Input)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLINEIN(ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÀÄnameÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÂÄÙ                    ³
 ³                             ÀÄlineÄÙ  ÀÄ,countÄÙ                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns count lines read from the character input stream name. The count 
 must be 0 or greater than 0. If you omit name, the line is read from the 
 default input stream, STDIN. The default count is 1. 
 
 For persistent streams, a read position is maintained for each stream. On 
 PC DOS, this is the same as the write position. Any read from the stream 
 starts at the current read position by default. (Under certain 
 circumstances, a call to LINEIN returns a partial line. This can happen if 
 the stream has already been read with the CHARIN function, and part but not 
 all of a line (and its termination, if any) has already been read.) When 
 the language processor completes reading, the read position is moved to the 
 beginning of the next line. The read position may be set to the beginning 
 of the stream by giving line a value of 1. 
 
 If you give a count of 0, then no characters are read and the null string 
 is returned. 
 
 For transient streams, if a complete line is not available in the stream, 
 then execution of the program usually stops until the line is complete. If, 
 however, it is impossible for a line to be completed because of an error or 
 other problem, the NOTREADY condition is raised and LINEIN returns whatever 
 characters are available. 
 
 Examples: 
 
 LINEIN()                             /* Reads one line from the    */
                                      /* default input stream;      */
                                      /* usually this is an entry   */
                                      /* typed at the keyboard      */
 myfile = 'ANYFILE.TXT'
 LINEIN(myfile)     -> 'Current line' /* Reads one line from        */
                                      /* ANYFILE.TXT, beginning     */
                                      /* at the current read        */
                                      /* position. (If first call,  */
                                      /* file is opened and the     */
                                      /* first line is read.)       */
 
 
 LINEIN(myfile,1,1) ->  'first line'  /* Opens and reads the first  */
                                      /* line of ANYFILE.TXT (if    */
                                      /* the file is already open,  */
                                      /* reads first line); sets    */
                                      /* read position on the       */
                                      /* second line.               */
 
 
 LINEIN(myfile,1,0) ->  ''            /* No read; opens ANYFILE.TXT */
                                      /* (if file is already open,  */
                                      /* sets the read position to  */
                                      /* the first line).           */
 
 LINEIN(myfile,,0)  ->  ''            /* No read; opens ANYFILE.TXT */
                                      /* (no action if the file is  */
                                      /* already open).             */
 
 Note: If the intention is to read complete lines from the default input 
 stream, as in a simple dialogue with a user, use the PULL or PARSE PULL 
 instruction instead for simplicity. The PARSE LINEIN instruction is also 
 useful in certain cases. 



LINEOUT (Line Output)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLINEOUT(ÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³               ÀÄnameÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÙ                  ³
 ³                              ÀÄstringÄÙ  ÀÄ,lineÄÙ                    ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the count of lines remaining after attempting to write string to 
 the character output stream name. The count is either 0 (meaning the line 
 was successfully written) or 1 (meaning that an error occurred while 
 writing the line). The string can be the null string, in which case the 
 only action is repositioning of the write position if repositioning is 
 specified. Otherwise, the stream is closed. LINEOUT adds a line-feed and a 
 carriage-return character to the end of string. 
 
 If you omit name, the line is written to the default output stream STDOUT 
 (usually the display). 
 
 For persistent streams, a write position is maintained for each stream. In 
 PC DOS, this is the same as the read position. Any write to the stream 
 starts at the current write position by default. (Under certain 
 circumstances the characters written by a call to LINEOUT may be added to a 
 partial line previously written to the stream with the CHAROUT routine.  
 LINEOUT stops a line at the end of each call.) When the language processor 
 completes writing, the write position is set to the beginning of the line 
 following the one just written. When the stream is first opened, the write 
 position is at the end of the stream, so that calls to LINEOUT will append 
 lines to the end of the stream. 
 
 You can set the write position to the first character of a persistent 
 stream by giving a value of 1 for line. Giving a value greater than 1 for 
 line will cause LINEOUT to overwrite the specified line in the stream.  If 
 the line being written to the stream is not exactly the same size as the 
 existing line, then the stream can become corrupted.  If the specified line 
 does not exist in the stream, then LINEOUT will append its output to the 
 stream. 
 
 You can omit the string for persistent streams. If you specify line, the 
 write position is set to the start of the line that was given, nothing is 
 written to the stream, and the function returns 0. If you specify neither 
 line nor string, the write position is set to the end of the stream. This 
 use of LINEOUT closes the streams in environments (such as PC DOS) that 
 support this concept. Again, the function returns 0. 
 
 Execution of the program usually stops until the output operation is 
 effectively complete. For example, when data is sent to a printer, the 
 system accepts the data and returns control to REXX, even though the output 
 data may not have been printed on the printer.  REXX considers this to be 
 complete, even though the data has not been printed. If, however, it is 
 impossible for a line to be written, the NOTREADY condition is raised and 
 LINEOUT returns a result of 1 (that is, the residual count of lines 
 written). 
 
 Examples: 
 
 LINEOUT(,'Display this')          /* Writes string to the default   */
                                   /* output stream (usually, the    */
                                   /* display); returns 0 if         */
                                   /* successful                     */
 
 myfile = 'ANYFILE.TXT'
 LINEOUT(myfile,'A new line')      /* Opens the file
 ANYFILE.TXT and */
                                   /* appends the string to the end. */
                                   /* If the file is already open,   */
                                   /* the string is written at the   */
                                   /* current write position.        */
                                   /* Returns 0 if successful.       */
 
 
 LINEOUT(myfile,'A new start',1)   /* Opens the file (if not already */
                                   /* open); overwrites first line   */
                                   /* with a new line.               */
                                   /* Returns 0 if successful.       */
 
 
 LINEOUT(myfile,,1)                /* Opens the file (if not already */
                                   /* open). No write; sets write    */
                                   /* position at first character.   */
 
 
 LINEOUT(myfile)                   /* Closes ANYFILE.TXT             */
 
 LINEOUT is often most useful when called as a subroutine. The return value 
 is then available in the variable RESULT. For example: 
 
 Call LINEOUT 'A:rexx.bat','Shell',1
 Call LINEOUT ,'Hello'
 
 Note: If the lines are to be written to the default output stream without 
 the possibility of error, use the SAY instruction instead. 



LINES (Lines Remaining)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄLINES(ÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³             ÀÄnameÄÙ                                                  ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the number of lines if any data remains between the current read 
 position and the end of the character input stream name; returns 0 if no 
 data remains. In effect, LINES reports whether a read action that CHARIN or 
 LINEIN performs will succeed. 
 
 If you omit name, then the presence or absence of data in the default input 
 stream (STDIN:) is returned. For PC DOS devices, LINES always returns 1. 
 For QUEUE: the actual number of lines is returned. 
 
 Examples: 
 
 LINES(myfile)    ->    0    /* at end of the file       */
 
 LINES(myfile)    ->    1    /* 1 line remaining in file */
 
 LINES()          ->    1    /* data remains in the      */
                             /* default input stream     */
                             /* STDIN:             */
 
 LINES("COM1:")   ->    1    /* A PC DOS device name     */
                             /* always returns '1'       */
 
 Note: The CHARS function returns the number of characters in a persistent 
 stream or the presence of data in a transient stream. 



MAX (Maximum)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³           ÚÄ,ÄÄÄÄÄÄ¿                                                  ³
 ³                   ³                                                  ³
 ³ >>ÄÄMAX(ÄÄÄÄnumberÄÁÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the largest number from the list specified, formatted according to 
 the current NUMERIC settings. 
 
 Examples: 
 
 MAX(12,6,7,9)                                           ->    12
 MAX(17.3,19,17.03)                                      ->    19
 MAX(-7,-3,-4.3)                                         ->    -3
 MAX(1,2,3,4,5,6,7,8,9,MAX(10,11,12,13))    ->   13
 
 Implementation maximum: You can specify up to 20 numbers, and can nest 
 calls to MAX if more arguments are needed. 



MIN (Minimum)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³           ÚÄ,ÄÄÄÄÄÄ¿                                                  ³
 ³                   ³                                                  ³
 ³ >>ÄÄMIN(ÄÄÄÄnumberÄÁÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the smallest number from the list specified, formatted according to 
 the current NUMERIC settings. 
 
 Examples: 
 
 MIN(12,6,7,9)                                                     ->   6
 MIN(17.3,19,17.03)                                                ->  17.03
 MIN(-7,-3,-4.3)                                                   ->  -7
 MIN(21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,MIN(2,1))   ->  1
 
 Implementation maximum: You can specify up to 20 numbers, and can nest 
 calls to MIN if more arguments are needed. 



OVERLAY
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                         ³
 ³ >>ÄÄOVERLAY(new,targetÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)Ä>< ³
 ³                         ÀÄ,ÄÄÂÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ       ³
 ³                              ÀÄnÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ         ³
 ³                                          ÀÄlengthÄÙ  ÀÄ,padÄÙ           ³
 ³                                                                         ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the string target, which, starting at the nth character, is 
 overlaid with the string new, padded or truncated to length length. (The 
 overlay may extend beyond the end of the original target string.) If you 
 specify length, it must be a positive whole number or zero. The default 
 value for length is the length of new.  If n is greater than the length of 
 the target string, padding is added before the new string. The default pad 
 character is a blank, and the default value for n is 1. If you specify n, 
 it must be a positive whole number. 
 
 Examples: 
 
 OVERLAY(' ','abcdef',3)         ->    'ab def'
 OVERLAY('.','abcdef',3,2)       ->    'ab. ef'
 OVERLAY('qq','abcd')            ->    'qqcd'
 OVERLAY('qq','abcd',4)          ->    'abcqq'
 OVERLAY('123','abc',5,6,'+')    ->    'abc+123+++'
 
 



POS (Position)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄPOS(needle,haystackÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                          ÀÄ,startÄÙ                                   ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the position of one string, needle, in another, haystack. (See also 
 the LASTPOS function.) Returns 0 if needle is the null string or is not 
 found or if start is greater than the length of haystack. By default the 
 search starts at the first character of haystack (that is, the value of 
 start is 1). You can override this by specifying start (which must be a 
 positive whole number), the point at which the search starts. 
 
 Examples: 
 
 POS('day','Saturday')       ->    6
 POS('x','abc def ghi')      ->    0
 POS(' ','abc def ghi')      ->    4
 POS(' ','abc def ghi',5)    ->    8
 
 



QUEUED
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄQUEUED()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the number of lines remaining in the external data queue when the 
 function is called. 
 
 Example: 
 
 QUEUED()    ->    5    /* Perhaps */
 
 



RANDOM
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄRANDOM(ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÃÄmaxÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                         ³
 ³              ÀÄÂÄmin,ÄÂÄÄÂÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÙ                         ³
 ³                ÀÄ,ÄÄÄÄÙ  ÀÄmaxÄÙ  ÀÄ,seedÄÙ                           ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a quasi-random nonnegative whole number in the range min to max 
 inclusive. If you specify max or min or both, max minus min cannot exceed 
 100000. The min and max default to 0 and 999, respectively. To start a 
 repeatable sequence of results, use a specific seed as the third argument, 
 as described in the Note below.  This seed must be a positive whole number 
 ranging from 0 to 999999999. 
 
 Examples: 
 
 RANDOM()          ->    305  /* Any number */
 RANDOM(5,8)       ->      7  /* Any number between 5 and 8, inclusive /*
 RANDOM(2)         ->      0  /*  0  to  2    */
 RANDOM(,,1983)    ->    123  /* reproducible */
 
 Notes: 
 
 1.  To obtain a predictable sequence of quasi-random numbers, use 
     RANDOM a number of times, but specify a seed only the first time. 
     For example, to simulate 40 throws of a 6-sided, unbiased die: 
     
     sequence = RANDOM(1,6,12345)  /* any number would */
                                   /* do for a seed    */
     do 39
        sequence = sequence RANDOM(1,6)
        end
     say sequence
     
     The numbers are generated mathematically, using the initial seed, 
     so that as far as possible they appear to be random. Running the 
     program again produces the same sequence; using a different initial 
     seed almost certainly produces a different sequence. If you do not 
     supply a seed, the first time RANDOM is called, an arbitrary seed 
     is used. Hence, your program usually gives different results each 
     time it is run. 
 2.  The random number generator is global for an entire program; the 
     current seed is not saved across internal routine calls. 
 



REVERSE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄREVERSE(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns string, swapped end for end. 
 
 Examples: 
 
 REVERSE('ABc.')    ->    '.cBA'
 REVERSE('XYZ ')    ->    ' ZYX'
 
 



RIGHT
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄRIGHT(string,lengthÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                          ÀÄ,padÄÙ                                     ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string of length length containing the rightmost length 
 characters of string. The string returned is padded with pad characters (or 
 truncated) on the left as needed. The default pad character is a blank. The 
 length must be a positive whole number or zero. 
 
 Examples: 
 
 RIGHT('abc  d',8)     ->    '  abc  d'
 RIGHT('abc def',5)    ->    'c def'
 RIGHT('12',5,'0')     ->    '00012'
 
 



SIGN
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSIGN(number)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a number that indicates the sign of number. The number is first 
 rounded according to standard REXX rules, just as though the operation 
 number+0 had been carried out. Returns -1 if number is less than 0; returns 
 0 if it is 0; and returns 1 if it is greater than 0. 
 
 Examples: 
 
 SIGN('12.3')       ->     1
 SIGN(' -0.307')    ->    -1
 SIGN(0.0)          ->     0
 
 



SOURCELINE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSOURCELINE(ÄÄÂÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                  ÀÄnÄÙ                                                ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the line number of the final line in the program if you omit n. If 
 you specify n, returns the nth line in the program if available at the time 
 of execution; otherwise, returns the null string. If specified, n must be a 
 positive whole number and must not exceed the number that a call to 
 SOURCELINE with no arguments returns. 
 
 Examples: 
 
 SOURCELINE()    ->   10
 SOURCELINE(1)   ->   '/* This is a 10-line REXX program */'
 
 



SPACE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSPACE(stringÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                   ÀÄ,ÄÄÂÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ                              ³
 ³                        ÀÄnÄÙ  ÀÄ,padÄÙ                                ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the blank-delimited words in string with n pad characters between 
 each word. If you specify n, it must be a positive whole number or zero. If 
 it is 0, all blanks are removed. Leading and trailing blanks are always 
 removed. The default for n is 1, and the default pad character is a blank. 
 
 Examples: 
 
 SPACE('abc  def  ')          ->    'abc def'
 SPACE('  abc def',3)         ->    'abc   def'
 SPACE('abc  def  ',1)        ->    'abc def'
 SPACE('abc  def  ',0)        ->    'abcdef'
 SPACE('abc  def  ',2,'+')    ->    'abc++def'
 
 



STREAM
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSTREAM(nameÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                  ³    ÚÄStateÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³                ³
 ³                  ÀÄ,ÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÙ                ³
 ³                       ÃÄCommandÄÄ,ÄÄstream_commandÄ´                  ³
 ³                       ÀÄDescriptionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                  ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string describing the state of, or the result of an operation 
 upon, the character stream name. The result may depend on characteristics 
 of the stream that you have specified in other uses of the STREAM function. 
 This function requests information on the state of an input or output 
 stream or carries out some specific operation on the stream. 
 
 The first argument, name, specifies the stream to be accessed. The second 
 argument can be one of the following strings that describe the action to be 
 carried out. (Only the capitalized and highlighted letter is needed; all 
 characters following it are ignored.) 
 
 Command      an operation (specified by the stream_command 
              given as the third argument) is applied to the 
              selected input or output stream. The string that 
              is returned depends on the command performed and 
              may be the null string. The possible input 
              strings for the stream_command argument are OPEN, 
              CLOSE, and SEEK. 
 Description  returns the current state of the specified 
              stream. It is identical to the State operation, 
              except that the returned string is followed by a 
              colon and, if available, additional information 
              about ERROR or NOTREADY states. 
 State        returns a string that indicates the current state 
              of the specified stream. This is the default 
              operation. 
              
              The strings returned are as follows: 
    
    ERROR      The stream has been subject to an erroneous 
               operation (possibly during input, output, or 
               through the STREAM function). You may be able 
               to obtain additional information about the 
               error by invoking the STREAM function with a 
               request for the description. 
    NOTREADY   The stream is known to be in a state such that 
               usual input or output operations attempted upon 
               it would raise the NOTREADY condition. For 
               example, a simple input stream may have a 
               defined length; an attempt to read that stream 
               (with the CHARIN or LINEIN built-in functions, 
               perhaps) beyond that limit may make the stream 
               unavailable until the stream has been closed 
               (for example, with LINEOUT("name")) and then 
               reopened. 
    READY      The stream is known to be in a state such that 
               usual input or output operations may be 
               attempted (this is the usual state for a 
               stream, though it does not guarantee that any 
               particular operation will succeed). 
    UNKNOWN    The state of the stream is unknown. This 
               generally means that the stream is closed (or 
               has not yet been opened). 
 
 
 Note: The state (and operation) of an input or output stream is global to a 
 REXX program; it is not saved and restored across internal function and 
 subroutine calls (including those calls that a CALL ON condition trap 
 causes). 
 
 Double-click on Stream Commands to continue. 



Stream Commands
 
 
 The following stream commands: 
   
   o Open a stream for reading or writing 
   o Close a stream at the end of an operation 
   o Move the line read or line write position within a persistent 
     stream (for example, a file) 
   o Get information about a stream (its existence, size, and last edit 
     date). 
   
 
 The stream_command argument must be used when-and only when-you select the 
 operation C (command). The syntax is: 
 
 >>ÄÄSTREAM(name,'C',stream_command)ÄÄ><
 
 Double-click on Command Strings to continue.  



Command Strings
 
 
 The argument stream_command can be any expression that REXX evaluates as 
 one of the following command strings: 
 
 'OPEN'              opens the named stream. The default 
                     for 'OPEN' is to open the stream 
                     for both reading and writing data. 
                     To specify whether name is only to 
                     be read or only to be written to, 
                     add the word 'READ' or 'WRITE' to 
                     the command string. 
                     
                     The STREAM function itself returns 
                     'READY' if the named stream is 
                     successfully opened or an 
                     appropriate error message if 
                     unsuccessful. 
                     
                     Examples: 
                     
                     stream(strout,'c','open')
                     stream(strout,'c','open write')
                     stream(strinp,'c','open read')
                     
                     
 'CLOSE'             closes the named stream. The STREAM 
                     function itself returns 'READY' if 
                     the named stream is successfully 
                     closed or an appropriate error 
                     message otherwise. If an attempt is 
                     made to close an unopened file, 
                     then STREAM returns a null string 
                     (""). 
                     
                     Example: 
                     
                     stream('STRM.TXT','c','close')
                     
                     
 'SEEKoffset '       sets the read or write position a 
                     given number (offset) within a 
                     persistent stream. The read and 
                     write positions are the same. To 
                     use this command, the named stream 
                     must first be opened (with the 
                     'OPEN' stream command, described 
                     previously). The offset number can 
                     be preceded by one of the following 
                     characters: 
    
    =    explicitly specifies the offset from the beginning of the 
         stream.  This is the default if no prefix is supplied. 
    <    specifies offset from the end of the stream. 
    +    specifies offset forward from the current read or write 
         position. 
    -    specifies offset backward from the current read or write 
         position.   
                     
                     The STREAM function itself returns 
                     the new position in the stream if 
                     the read or write position is 
                     successfully located or an 
                     appropriate error message 
                     otherwise. 
                     
                     Examples: 
                     
                     stream(name,'c','seek =2')
                     stream(name,'c','seek +15')
                     stream(name,'c','seek -7')
                     fromend  = 125
                     stream(name,'c','seek <'fromend)
                     
                     
 
 
 Double-click on QUERY Stream Commands to continue. 



QUERY Stream Commands
 
 
 Used with these stream commands, the STREAM function returns specific 
 information about a stream 
 
 'QUERY EXISTS'      returns the full path specification 
                     of the named stream, if it exists 
                     or a null string otherwise. 
                     
                     stream('..\file.txt','c','query exists')
                     
                     A sample output might be: 
                     
                     C:\CONFIG.SYS
                     
                     
 'QUERY SIZE'        returns the size in bytes of a 
                     persistent stream. 
                     
                     stream('..\file.txt','c','query size')
                     
                     A sample output might be: 
                     
                     1305
                     
                     
 'QUERY DATETIME'    returns the date and time stamps of 
                     a stream. 
                     
                     stream('..\file.txt','c','query datetime')
                     
                     A sample output might be: 
                     
                     12-11-91 03:29:12
                     
                     
 



STRIP
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSTRIP(stringÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                   ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÙ                        ³
 ³                        ÀÄoptionÄÙ  ÀÄ,charÄÙ                          ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns string with leading or trailing characters or both removed, based 
 on the option you specify. The following are valid options. (Only the 
 capitalized and highlighted letter is needed; all characters following it 
 are ignored.) 
 
 Both        removes both leading and trailing characters from 
             string. This is the default. 
 Leading     removes leading characters from string. 
 Trailing    removes trailing characters from string. 
 
 
 The third argument, char, specifies the character to be removed, and the 
 default is a blank. If you specify char, it must be exactly one character 
 long. 
 
 Examples: 
 
 STRIP('  ab c  ')        ->    'ab c'
 STRIP('  ab c  ','L')    ->    'ab c  '
 STRIP('  ab c  ','t')    ->    '  ab c'
 STRIP('12.7000',,0)      ->    '12.7'
 STRIP('0012.700',,0)     ->    '12.7'
 
 



SUBSTR (Substring)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSUBSTR(string,nÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                      ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ                      ³
 ³                           ÀÄlengthÄÙ  ÀÄ,padÄÙ                        ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the substring of string that begins at the nth character and is of 
 length length, padded with pad if necessary. The n must be a positive whole 
 number. If n is greater than LENGTH(string), then only pad characters are 
 returned. 
 
 If you omit length, the rest of the string is returned.  The default pad 
 character is a blank. 
 
 Examples: 
 
 SUBSTR('abc',2)          ->    'bc'
 SUBSTR('abc',2,4)        ->    'bc  '
 SUBSTR('abc',2,6,'.')    ->    'bc....'
 
 Note: In some situations the positional (numeric) patterns of parsing 
 templates are more convenient for selecting substrings, especially if more 
 than one substring is to be extracted from a string. 



SUBWORD
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSUBWORD(string,nÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                       ÀÄ,lengthÄÙ                                     ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the substring of string that starts at the nth word, and is up to 
 length blank-delimited words. The n must be a positive whole number. If you 
 omit length, it defaults to the number of remaining words in string. The 
 returned string never has leading or trailing blanks, but includes all 
 blanks between the selected words. 
 
 Examples: 
 
 SUBWORD('Now is the  time',2,2)    ->    'is the'
 SUBWORD('Now is the  time',3)      ->    'the  time'
 SUBWORD('Now is the  time',5)      ->    ''
 
 



SYMBOL
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄSYMBOL(name)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the state of the symbol named by name. Returns BAD if name is not a 
 valid REXX symbol. Returns VAR if it is the name of a variable (that is, a 
 symbol that has been assigned a value). Otherwise returns LIT, indicating 
 that it is either a constant symbol or a symbol that has not yet been 
 assigned a value (that is, a literal). 
 
 As with symbols in REXX expressions, lowercase characters in name are 
 translated to uppercase and substitution in a compound name occurs if 
 possible. 
 
 Note: You should specify name as a literal string (or it should be derived 
 from an expression) to prevent substitution before it is passed to the 
 function. 
 
 Examples: 
 
 /* following: Drop A.3;  J=3 */
 SYMBOL('J')      ->   'VAR'
 SYMBOL(J)        ->   'LIT' /* has tested "3"     */
 SYMBOL('a.j')    ->   'LIT' /* has tested A.3     */
 SYMBOL(2)        ->   'LIT' /* a constant symbol  */
 SYMBOL('*')      ->   'BAD' /* not a valid symbol */
 
 



TIME
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄTIME(ÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³            ÀÄoptionÄÙ                                                 ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the local time in the 24-hour clock format: hh:mm:ss (hours, 
 minutes, and seconds) by default, for example, 04:41:37. 
 
 You can use the following options to obtain alternative formats, or to gain 
 access to the elapsed-time clock. (Only the capitalized and highlighted 
 letter is needed; all characters following it are ignored.) 
 
 Civil     returns the time in Civil format: hh:mmxx. The hours 
           may take the values 1 through 12, and the minutes the 
           values 00 through 59. The minutes are followed 
           immediately by the letters am or pm. This distinguishes 
           times in the morning (12 midnight through 
           11:59 a.m.-appearing as 12:00am through 11:59am) from 
           noon and afternoon (12 noon through 
           11:59 p.m.-appearing as 12:00pm through 11:59pm). The 
           hour has no leading zero.  The minute field shows the 
           current minute (rather than the nearest minute) for 
           consistency with other TIME results. 
 Elapsed   returns sssssssss.uu0000, the number of 
           seconds.hundredths since the elapsed-time clock was 
           started or reset (see below). The returned number has 
           no leading zeros or blanks but always has four trailing 
           zeros in the decimal portion. It is not affected by the 
           setting of NUMERIC DIGITS. 
           
           REXX calculates elapsed time by subtracting the time 
           the elapsed-time clock was started or reset from the 
           current time. It is possible to change the system time 
           clock while the system is running.  This means that the 
           elapsed time value REXX calculates might not be a true 
           elapsed time.  If the time is changed so that the 
           system time is earlier than when the REXX elapsed-time 
           clock was started (so that the elapsed time would 
           appear negative), REXX raises an error and disables the 
           elapsed-time clock.  To restart the elapsed-time clock, 
           trap the error through SIGNAL ON SYNTAX. To change the 
           system time clock, use the PC DOS TIME command. The 
           clock can also be changed by programs on the system.  
           Many LAN-attached programs synchronize the system time 
           clock with the system time clock of the server during 
           startup.  This causes the REXX elapsed time function to 
           be unreliable during LAN initialization. 
 Hours     returns up to two characters giving the number of hours 
           since midnight in the format: hh (no leading zeros or 
           blanks, except for a result of 0). 
 Long      returns time in the format hh:mm:ss.uu0000 (where uu is 
           the fraction of seconds in hundredths of a second). 
 Minutes   returns up to four characters giving the number of 
           minutes since midnight in the format: mmmm (no leading 
           zeros or blanks, except for a result of 0). 
 Normal    returns the time in the default format hh:mm:ss, as 
           described previously. The hours can have the values 00 
           through 23, and minutes and seconds, 00 through 59. All 
           these are always two digits. Any fractions of seconds 
           are ignored (times are never rounded up). This is the 
           default. 
 Reset     returns sssssssss.uu0000, the number of 
           seconds.hundredths since the elapsed-time clock was 
           started or reset (see below) and also resets the 
           elapsed-time clock to zero. The returned number has no 
           leading zeros or blanks, but always has four trailing 
           zeros in the decimal portion. 
           
           Refer to the Elapsed option for more information on 
           resetting the system time clock. 
 Seconds   returns up to five characters giving the number of 
           seconds since midnight in the format: sssss (no leading 
           zeros or blanks, except for a result of 0). 
 
 
 Examples: ( assuming that the time is 4:54 p.m.) 
 
 TIME()       ->   '16:22'
 TIME('C')    ->   '4:54pm'
 TIME('H')    ->   '16'
 TIME('L')    ->   '16:54:22.120000'   /* Perhaps */
 TIME('M')    ->   '1014'           /* 54 + 60*16 */
 TIME('N')    ->   '16:22'
 TIME('S')    ->   '60862'  /* 22 + 60*(54+60*16) */
 
 Here is an example of the elapsed-time clock: 
 
 time('E')    ->    0          /* the first call */
 /* pause of one second here */
 time('E')    ->    1.020000   /* or thereabouts */
 /* pause of one second here */
 time('R')    ->    2.030000   /* or thereabouts */
 /* pause of one second here */
 time('R')    ->    1.050000   /* or thereabouts */
 
 
 
 



TRACE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄTRACE(ÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³             ÀÄoptionÄÙ                                                ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns trace actions currently in effect and, optionally, alters the 
 setting. 
 
 If you specify option, it selects the trace setting. It must be the valid 
 prefix ? or one of the alphabetic character options associated with the 
 TRACE instruction (that is, starting with A, C, E, F, I, L, N, O, or R) or 
 both. (See the TRACE instruction for full details.) 
 
 Unlike the TRACE instruction, the TRACE function alters the trace action 
 even if interactive debug is active. Also unlike the TRACE instruction, 
 option cannot be a number. 
 
 Examples: 
 
 TRACE()       ->   '?R' /* maybe */
 TRACE('O')    ->   '?R' /* also sets tracing off    */
 TRACE('?I')   ->   'O'  /* now in interactive debug */
 
 



TRANSLATE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                          ³
 ³>>ÄÄTRANSLATE(stringÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)Ä><³
 ³                      ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ      ³
 ³                           ÀÄtableoÄÙ  ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÙ        ³
 ³                                            ÀÄtableiÄÙ  ÀÄ,padÄÙ          ³
 ³                                                                          ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns string with each character translated to another character or 
 unchanged. You can also use this function to reorder the characters in 
 string. 
 
 The output table is tableo and the input translation table is tablei. 
 TRANSLATE searches tablei for each character in string. If the character is 
 found, then the corresponding character in tableo is used in the result 
 string; if there are duplicates in tablei, the first (leftmost) occurrence 
 is used. If the character is not found, the original character in string is 
 used. The result string is always the same length as string. 
 
 The tables can be of any length. If you specify neither translation table 
 and omit pad, string is simply translated to uppercase (that is, lowercase 
 a-z to uppercase A-Z), but, if you include pad, the language processor 
 translates the entire string to pad characters. tablei defaults to 
 XRANGE('00'x,'FF'x), and tableo defaults to the null string and is padded 
 with pad or truncated as necessary. The default pad is a blank. 
 
 Examples: 
 
 TRANSLATE('abcdef')                    ->    'ABCDEF'
 TRANSLATE('abbc','&','b')              ->    'a&:c'
 TRANSLATE('abcdef','12','ec')          ->    'ab2d1f'
 TRANSLATE('abcdef','12','abcd','.')    ->    '12..ef'
 TRANSLATE('APQRV',,'PR')               ->    'A Q V'
 TRANSLATE('APQRV',XRANGE('00'X,'Q'))   ->    'APQ  '
 TRANSLATE('4123','abcd','1234')        ->    'dabc'
 
 Note: The last example shows how to use the TRANSLATE function to reorder 
 the characters in a string.  In the example, the last character of any 
 four-character string specified as the second argument would be moved to 
 the beginning of the string. 



TRUNC (Truncate)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄTRUNC(numberÄÄÂÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                   ÀÄ,nÄÙ                                              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the integer part of number and n decimal places. The default n is 0 
 and returns an integer with no decimal point. If you specify n, it must be 
 a positive whole number or zero. The number is first rounded according to 
 standard REXX rules, just as though the operation number+0 had been carried 
 out. The number is then truncated to n decimal places (or trailing zeros 
 are added if needed to make up the specified length). The result is never 
 in exponential form. 
 
 Examples: 
 
 TRUNC(12.3)           ->    12
 TRUNC(127.09782,3)    ->    127.097
 TRUNC(127.1,3)        ->    127.100
 TRUNC(127,2)          ->    127.00
 
 Note: The number is rounded according to the current setting of NUMERIC 
 DIGITS if necessary before the function processes it.  



VALUE
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄVALUE(nameÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                 ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÙ                    ³
 ³                      ÀÄnewvalueÄÙ  ÀÄ,selectorÄÙ                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the value of the symbol that name (often constructed dynamically) 
 represents and optionally assigns it a new value. By default, VALUE refers 
 to the current REXX-variables environment, but other, external collections 
 of variables may be selected. If you use the function to refer to REXX 
 variables, then name must be a valid REXX symbol. (You can confirm this by 
 using the SYMBOL function.) Lowercase characters in name are translated to 
 uppercase. Substitution in a compound name occurs if possible. 
 
 If you specify newvalue, then the named variable is assigned this new 
 value. This does not affect the result returned; that is, the function 
 returns the value of name as it was before the new assignment. 
 
 Examples: 
 
      /* After: Drop A3; A33=7; K=3; fred='K'; list.5='Hi' */
      VALUE('a'k)     ->  'A3' /* looks up A3     */
      VALUE('a'k||k)  ->  '7'
      VALUE('fred')   ->  'K'  /* looks up FRED   */
      VALUE(fred)     ->  '3'  /* looks up K      */
      VALUE(fred,5)   ->  '3'  /* looks up K and  */
                               /* then sets K=5   */
      VALUE(fred)     ->  '5'  /* looks up K      */
      VALUE('LIST.'k) ->  'Hi' /* looks up LIST.5 */
 
 
 
 To use VALUE to manipulate PC DOS environment variables, selector must be 
 the string "DOSENVIRONMENT" or an expression so evaluated. In this case, 
 the variable name need not be a valid REXX symbol. When VALUE sets or 
 changes the value of an environment variable, the new value is retained 
 after the REXX procedure ends. 
 
 Restriction: The values assigned to the variables must not contain any 
 character that is a hexadecimal zero ('00'X).  For example, Call VALUE 
 'MYVAR', 'FIRST' || '00'X || 'SECOND', 'DOSENVIRONMENT' sets MYVAR to 
 "FIRST", truncating the '00'x and 'SECOND'. 
 
 Notes: 
 
 1.  If the VALUE function refers to an uninitialized REXX variable then 
     the default value of the variable is always returned; the NOVALUE 
     condition is not raised. A reference to an external collection of 
     variables never raises NOVALUE. 
 2.  The VALUE function is used when a variable contains the name of 
     another variable, or when a name is constructed dynamically. If you 
     specify the name as a single literal string and omit newvalue and 
     selector, the symbol is a constant and so the string between the 
     quotation marks can usually replace the whole function call.  For 
     example, fred=VALUE('k'); is identical with the assignment 
     fred=k;, unless the NOVALUE condition is being trapped. 
 



VERIFY
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄVERIFY(string,referenceÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄ>< ³
 ³                              ÀÄ,ÄÄÂÄÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÄÂÄÙ            ³
 ³                                   ÀÄoptionÄÙ  ÀÄ,startÄÙ              ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a number that, by default, indicates whether string is composed 
 only of characters from reference;  returns 0 if all characters in string 
 are in reference, or returns the position of the first character in string 
 not in reference. 
 
 The option can be either Nomatch (the default) or M. (Only the capitalized 
 and highlighted letter is needed. All characters following it are ignored, 
 and it can be in upper- or lowercase, as usual.) If you specify Match, the 
 function returns the position of the first character in string that is in 
 reference, or returns 0 if none of the characters are found. 
 
 The default for start is 1; thus, the search starts at the first character 
 of string. You can override this by specifying a different start point, 
 which must be a positive whole number. 
 
 If string is null, the function returns 0, regardless of the value of the 
 third argument. Similarly, if start is greater than LENGTH(string), the 
 function returns 0. If reference is null, the function returns 0 if you 
 specify Match; otherwise the function returns the start value. 
 
 Examples: 
 
 VERIFY('123','1234567890')             ->    0
 VERIFY('1Z3','1234567890')             ->    2
 VERIFY('AB4T','1234567890')            ->    1
 VERIFY('AB4T','1234567890','M')        ->    3
 VERIFY('AB4T','1234567890','N')        ->    1
 VERIFY('1P3Q4','1234567890',,3)        ->    4
 VERIFY('123','',N,2)                   ->    2
 VERIFY('ABCDE','',,3)                  ->    3
 VERIFY('AB3CD5','1234567890','M',4)    ->    6
 
 



WORD
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄWORD(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the nth blank-delimited word in string or returns the null string 
 if fewer than n words are in string. The n must be a positive whole number. 
 This function is exactly equivalent to SUBWORD(string,n,1). 
 
 Examples: 
 
 WORD('Now is the time',3)    ->    'the'
 WORD('Now is the time',5)    ->    ''
 
 



WORDINDEX
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄWORDINDEX(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the position of the first character in the nth blank-delimited word 
 in string or returns 0 if fewer than n words are in string. The n must be a 
 positive whole number. 
 
 Examples: 
 
 WORDINDEX('Now is the time',3)    ->    8
 WORDINDEX('Now is the time',6)    ->    0
 
 



WORDLENGTH
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄWORDLENGTH(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the length of the nth blank-delimited word in string or returns 0 
 if fewer than n words are in string. The n must be a positive whole number. 
 
 Examples: 
 
 WORDLENGTH('Now is the time',2)       ->    2
 WORDLENGTH('Now comes the time',2)    ->    5
 WORDLENGTH('Now is the time',6)       ->    0
 
 



WORDPOS (Word Position)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄWORDPOS(phrase,stringÄÄÂÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                            ÀÄ,startÄÙ                                 ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the word number of the first word of phrase found in string or 
 returns 0 if phrase contains no words or if phrase is not found. Multiple 
 blanks between words in either phrase or string are treated as a single 
 blank for the comparison, but otherwise the words must match exactly. 
 
 By default the search starts at the first word in string. You can override 
 this by specifying start (which must be positive), the word at which to 
 start the search. 
 
 Examples: 
 
 WORDPOS('the','now is the time')              ->  3
 WORDPOS('The','now is the time')              ->  0
 WORDPOS('is the','now is the time')           ->  2
 WORDPOS('is   the','now is the time')         ->  2
 WORDPOS('is   time ','now is   the time')     ->  0
 WORDPOS('be','To be or not to be')            ->  2
 WORDPOS('be','To be or not to be',3)          ->  6
 
 



WORDS
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄWORDS(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the number of blank-delimited words in string. 
 
 Examples: 
 
 WORDS('Now is the time')    ->    4
 WORDS(' ')                  ->    0
 
 



XRANGE (Hexadecimal Range)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄXRANGE(ÄÄÂÄÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³              ÀÄstartÄÙ  ÀÄ,endÄÙ                                      ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string of all valid 1-byte encodings (in ascending order) between 
 and including the values start and end. The default value for start is 
 '00'x, and the default value for end is 'FF'x. If start is greater than 
 end, the values wrap from 'FF'x to '00'x. If specified, start and end must 
 be single characters. 
 
 Examples: 
 
 XRANGE('a','f')      ->   'abcdef'
 XRANGE('03'x,'07'x)  ->   '0304050607'x
 XRANGE(,'04'x)       ->   '0001020304'x
 XRANGE('FE'x,'02'x)  ->   'FEFF000102'x
 XRANGE('i','j')      ->   'ij'                   /* ASCII  */
 
 



X2B (Hexadecimal to Binary)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄX2B(hexstring)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that represents hexstring converted 
 to binary. The hexstring is a string of hexadecimal characters. It can be 
 of any length.  Each hexadecimal character is converted to a string of four 
 binary digits. You can optionally include blanks in hexstring (at byte 
 boundaries only, not leading or trailing) to aid readability; they are 
 ignored. 
 
 The returned string has a length that is a multiple of four, and does not 
 include any blanks. 
 
 If hexstring is null, the function returns a null string. 
 
 Examples: 
 
 X2B('C3')        ->  '11000011'
 X2B('7')         ->  '0111'
 X2B('1 C1')      ->  '000111000001'
 
 You can combine X2B with the functions D2X and C2X to convert numbers or 
 character strings into binary form. 
 
 Examples: 
 
 X2B(C2X('C3'x))  ->  '11000011'
 X2B(D2X('129'))  ->  '10000001'
 X2B(D2X('12'))   ->  '1100'
 
 



X2C (Hexadecimal to Character)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄX2C(hexstring)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns a string, in character format, that represents hexstring converted 
 to character. The returned string is half as many bytes as the original 
 hexstring. hexstring can be of any length. If necessary, it is padded with 
 a leading 0 to make an even number of hexadecimal digits. 
 
 You can optionally include blanks in hexstring (at byte boundaries only, 
 not leading or trailing) to aid readability; they are ignored. 
 
 If hexstring is null, the function returns a null string. 
 
 Examples: 
 
 X2C('4865 6c6c 6f') ->  'Hello'     /*  ASCII             */
 X2C('3732 73')      ->  '72s'       /*  ASCII             */
 
 



X2D (Hexadecimal to Decimal)
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                       ³
 ³ >>ÄÄX2D(hexstringÄÄÂÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
 ³                    ÀÄ,nÄÙ                                             ³
 ³                                                                       ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 returns the decimal representation of hexstring.  The hexstring is a string 
 of hexadecimal characters. If the result cannot be expressed as a whole 
 number, an error results. That is, the result must not have more digits 
 than the current setting of NUMERIC DIGITS. 
 
 You can optionally include blanks in hexstring (at byte boundaries only, 
 not leading or trailing) to aid readability; they are ignored. 
 
 If hexstring is null, the function returns 0. 
 
 If you do not specify n, hexstring is processed as an unsigned binary 
 number. 
 
 Examples: 
 
 X2D('0E')        ->    14
 X2D('81')        ->    129
 X2D('F81')       ->    3969
 X2D('FF81')      ->    65409
 
 If you specify n, the string is taken as a signed number expressed in n 
 hexadecimal digits. If the leftmost bit is off, then the number is 
 positive; otherwise, it is a negative number in two's complement notation. 
 In both cases it is converted to a whole number, which may, therefore, be 
 negative. If n is 0, the function returns 0. 
 
 If necessary, hexstring is padded on the left with 0 characters (note, not 
 "sign-extended"), or truncated on the left to n characters. 
 
 Examples: 
 
 X2D('81',2)      ->    -127
 X2D('81',4)      ->    129
 X2D('F081',4)    ->    -3967
 X2D('F081',3)    ->    129
 X2D('F081',2)    ->    -127
 X2D('F081',1)    ->    1
 X2D('0031',0)    ->    0
 
 



External Functions (Utilities)
 
 
 REXX provides external functions (also referred to as utilities) that can 
 be used to perform functions such as: 
 
 o Manipulate PC DOS files and directories 
 o Perform text screen input and output 
 
 
 The format and call of REXX utilities in PC DOS is different from that of 
 other platforms, such as OS/2*, which has Dynamic Link Library (DLL) 
 support, or NetWare*, which has NetWare Loadable Modules (NLM) support. A 
 REXX utility can be invoked by the CALL instruction or you can call it as a 
 function call the same way that you call the REXX built-in functions.  See 
 "Functions" for more information. 
 
 For example, to execute the RXISDIR utility using the CALL instruction, 
 enter CALL RXISDIR 'C:\DOS'. The result of a utility is returned in the 
 variable RESULT.  For this particular example, you can accomplish the same 
 result by entering variable=RXISDIR('C:\DOS'). See the CALL instruction for 
 more information on calling REXX utilities. 
 
 Double-click on Quick Reference of REXX Utilities to continue.  



Quick Reference of REXX Utilities
 The following table is a summary of REXX utilities. 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³Utility        ³Action                                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXCHDIR        ³Changes to the specified directory.               ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXCHDRV        ³Changes to the specified drive.                   ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXCLS          ³Clears the screen or, optionally, a rectangular   ³
 ³               ³region of the screen, using the specified         ³
 ³               ³attribute.                                        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXCREATE       ³Creates the specified file.                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXCRSTAT       ³Sets the cursor state.                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXDELETE       ³Deletes a specified file.                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXDINFO        ³Returns information about the specified drive.    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXDOSVER       ³Returns the PC DOS version.                       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXFINFO        ³Returns information about a specified file.       ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXGETDIR       ³Returns the current directory on the specified or ³
 ³               ³current drive.                                    ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXGETDRV       ³Returns the current drive.                        ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXGETKEY       ³Returns (optionally without ECHO) the next key    ³
 ³               ³from the keyboard buffer.                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXGETMEM       ³Returns the amount of free memory available.      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXGETPOS       ³Returns the cursor position.                      ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXISDIR        ³Returns a value indicating whether the filename is³
 ³               ³a file or a directory.                            ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXMKDIR        ³Creates a subdirectory.                           ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXNETDRV       ³Returns a value indicating whether a drive is     ³
 ³               ³local or remote.                                  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXQSYS         ³Returns the specified system information.         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXRMDIR        ³Removes a file directory.                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXSCRSIZ       ³Returns the screen size.                          ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXSETPOS       ³Sets the cursor position.                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXSLEEP        ³Pauses a REXX program for a specified time        ³
 ³               ³interval.                                         ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³RXWRSCR        ³Writes the specified string to the screen starting³
 ³               ³at the current cursor position.                   ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 For detailed information on each of these REXX utilities, or to learn how 
 to write your own, see the "PC DOS 7 REXX User's Guide and Reference". 



RXCHDIR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXCHDIR(path)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if the current directory has successfully changed to path.  
   Otherwise, a PC DOS error code is returned. See PC DOS Error Codes for 
   more information. 
 
 Examples: 
   
   RXCHDIR('C:\TEST')    -> 0
   RXCHDIR('\DOS')       -> 0
   RXCHDIR('Z:\BAD')     -> 3   /* Path not found */
   
    



RXCHDRV
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXCHDRV(drive)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if the current drive has successfully changed to drive.  
   Otherwise, a PC DOS error code is returned. See PC DOS Error Codes for 
   more information. 
 
 Examples: 
   
   RXCHDRV('C:')         -> 0
   RXCHDRV('Z:')         -> 15    /* Invalid drive was specified */
   
    



RXCLS
 Syntax 
 
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³                                                                                 ³
 ³ >>ÄÄRXCLS(ÄÄÂÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄ)Ä>< ³
 ³             ÀÄattribÄÙ ÀÄ,startrowÄÙ À,startcolÄÙ ÀÄ,endrowÄÙ ÀÄ,endcolÄÙ       ³
 ³                                                                                 ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
 clears the screen or, optionally, a rectangular region of the screen, using 
 the specified attribute. 
 
 Notes: 
   
   o If no attrib is specified, a default attribute of 7 (white text on 
     a black background) will be used.  See the RXWRSCR command for a 
     list of available screen attributes. 
   o When clearing a region of the screen, the region to clear is always 
     rectangular.  It is specified by providing the screen coordinates 
     of the upper-left corner and lower-right corner of the rectangle. 
     startrow and startcol represent the screen coordinates of the 
     upper-left corner of the region to clear.  endrow and endcol 
     represent the screen coordinates of the lower-right corner of the 
     region to clear. 
   o If startrow or startcol are not specified, they will default to 0. 
   o If endrow is not specified, it will default to the last row on the 
     screen. For example, if the screen is in a 25-line mode, endrow 
     will default to 24. 
   o If endcol is not specified, it will default to the last column on 
     the screen.  For example, if the screen is in an 80-column mode, 
     endcol will default to 79. 
   o If RXCLS is called without parameters, it will clear the entire 
     screen using the default attribute. 
   o The output of RXCLS cannot be redirected. 
   o RXCLS ignores any screen background color established using 
     ANSI.SYS. 
   o RXCLS leaves the cursor in the upper-left corner of the region 
     cleared. 
   
 
 Examples: 
 
 To clear the entire screen using the default attribute: 
 
     RXCLS()
 
 To clear the entire screen using a specific attribute: 
 
     RXCLS(30)
 
 To clear rows 5 through 10 using the default attribute: 
 
     RXCLS(,5,,10,79)
 
 



RXCREATE
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXCREATE(filenameÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                       ÀÄ,NEWÄÙ                                       ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if filename has been successfully created. If the optional 
   parameter NEW is specified, filename is successfully created only if it 
   does not currently exist. Otherwise, a PC DOS error code is returned. 
   See PC DOS Error Codes for more information. 
 
 Examples: 
   
   RXCREATE('TEST.FIL')          -> 0
   RXCREATE('C:\DOS\TEST.TXT')   -> 0
   RXCREATE('Z:\BAD.TXT')        -> 3   /* Path not found */
   
    



RXCRSTAT
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXCRSTAT(ÂÄONÄÄÂ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³              ÀÄOFFÄÙ                                                 ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   sets the cursor state. If you specify ON, the cursor turns on and if 
   you specify OFF, the cursor disappears. 
 
 Examples: 
   
   RXCRSTAT('ON')
   RXCRSTAT('OFF')
   
   



RXDELETE
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXDELETE(filename)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if filename has been successfully deleted. Otherwise, a PC 
   DOS error code is returned. See PC DOS Error Codes for more 
   information. 
 
 Examples: 
   
   RXDELETE('TEST.FIL')          -> 0
   RXDELETE('C:\DOS\TEST.TXT')   -> 0
   RXDELETE('C:\BAD.TXT')        -> 2  /* file does not exist */
   
   



RXDINFO
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                       ³
   ³ >>ÄÄRXDINFO(drive)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                       ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns drive information if the drive exists. Otherwise, no 
   information is returned. 
 
 Examples: 
   
   RXDINFO('C:')         -> 'C:  97432 10769400 REXXDISK'
   RXDINFO('Z:')         -> ''
   
   As shown in the example, the information returned shows the status of 
   the drive you specified.  The return values are: 
     
     o Drive letter 
     o Free space 
     o Total space 
     o Volume label 
      



RXDOSVER
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXDOSVER()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the PC DOS version. 
 
 Example: 
   
   RXDOSVER()            -> '7.00'
   
   



RXFINFO
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXFINFO(filename)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns information about the specified filename, if the file exists; 
   or returns information about multiple file names if a wildcard is 
   specified.  Otherwise, no information is returned. 
 
 Examples: 
   
   RXFINFO('TEST.FIL')   -> 'TEST.FIL 15070 09/20/94 09:00 -A---'
   RXFINFO('*.FIL')      -> 'TEST.FIL 15070 09/20/94 09:13 -A---'
   RXFINFO()             -> 'TEST1.FIL 27345 09/20/94 09:14 -A---'
   RXFINFO()             -> 'TEST2.FIL 13141 09/20/94 09:15 -A---'
   RXFINFO()             -> ''
   
   As shown in the example, the information returned shows the status of 
   the file you specified.  The return values are: 
     
     o File name 
     o File size 
     o Date 
     o Time 
     o File attribute 
      



RXGETDIR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXGETDIR(drive)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the current directory of the specified drive, if drive is 
   valid. If the optional drive is not specified, the current directory of 
   the current drive is returned. Otherwise, no information is returned. 
 
 Examples: 
   
   RXGETDIR('C:')        -> '\DOS'
   RXGETDIR('Z:')        -> ''
   
    



RXGETDRV
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXGETDRV()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the current drive. 
 
 Example: 
   
   RXGETDRV()            -> 'C:'
   
    



RXGETKEY
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXGETKEY(ÄÂÄECHOÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³               ÀÄNOECHOÄÙ                                             ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the next key from the keyboard buffer. If you specify ECHO the 
   key is displayed on the screen, NOECHO does not display the key on the 
   screen. 
 
 Examples: 
   
   RXGETKEY()            -> 'A'   /* 'A' was entered and appeared on the screen       */
   RXGETKEY('ECHO')      -> 'L'   /* 'L' was entered and appeared on the screen       */
   RXGETKEY('NOECHO')    -> 'A'   /* 'A' was entered but did not appear on the screen */
   RXGETKEY()            -> 'N'   /* 'N' was entered and appeared on the screen       */
   
    



RXGETMEM
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXGETMEM()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the amount of free memory available. 
 
 Example: 
   
   RXGETMEM()            -> '449344'
   
   
 
 Note: 
   
   The returned value differs from system to system.  



RXGETPOS
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXGETPOS()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the cursor position in rows and columns. For example, for a 
   25x80 display, a row can be 0 to 24 and a column can be 0 to 79. 
 
 Examples: 
   
   RXGETPOS()            -> '5 10'
   RXGETPOS()            -> '24 79'
   
    



RXISDIR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXISDIR(name)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if name is a file or 1 if name is a directory.  Otherwise, no 
   information is returned. 
 
 Examples: 
   
   RXISDIR('TEST.FIL')   -> 0
   RXISDIR('\DOS')       -> 1
   RXISDIR('BAD.FIL')    -> ''
   
    



RXMKDIR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXMKDIR(path)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if the directory path was successfully created.  Otherwise, a 
   PC DOS error code is returned. See PC DOS Error Codes for more 
   information. 
 
 Examples: 
   
   RXMKDIR('DRIVER1')    -> 0
   RXMKDIR('\BADDIR')    -> 0
   RXMKDIR('DRIVER1')    -> 5  /* Access denied */
   
    



RXNETDRV
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXNETDRV(drive)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if drive is local or 1 if drive is remote. Otherwise, no 
   information is returned. 
 
 Examples: 
   
   RXNETDRV('C:')        -> 0
   RXNETDRV('D:')        -> 1
   RXNETDRV('Z:')        -> ''
   
    



RXQSYS
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXQSYS(ÂÄCPUÄÄÄÄÄÄÂ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³            ÃÄFPUÄÄÄÄÄÄ´                                              ³
   ³            ÃÄVIDEOÄÄÄÄ´                                              ³
   ³            ÃÄMONITORÄÄ´                                              ³
   ³            ÃÄKEYBOARDÄ´                                              ³
   ³            ÃÄFLOPPYÄÄÄ´                                              ³
   ³            ÃÄFIXEDÄÄÄÄ´                                              ³
   ³            ÃÄSERIALÄÄÄ´                                              ³
   ³            ÀÄPARALLELÄÙ                                              ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the specified system information.  You can only query one 
   variable at a time. 
 
 Examples: 
   
   RXQSYS('CPU')         -> '80486'
   RXQSYS('SERIAL')      -> '2'
   
   
   
   The system information that can be queried is: 
   
   CPU            processor type 
   FPU            0 if not present, 1 if present 
   VIDEO          video card type 
   MONITOR        color or monochrome 
   KEYBOARD       standard or enhanced 
   FLOPPY         number of floppy drives 
   FIXED          number of fixed drives 
   SERIAL         number of serial ports 
   PARALLEL       number of parallel ports 
    



RXRMDIR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXRMDIR(path)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns 0 if the directory path was successfully deleted.  Otherwise, a 
   PC DOS error code is returned. See PC DOS Error Codes for more 
   information. 
 
 Examples: 
   
   RXRMDIR('DRIVER1')    -> 0
   RXRMDIR('\BADDIR')    -> 0
   RXRMDIR('DRIVER1')    -> 5  /* Access denied */
   
    



RXSCRSIZ
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXSCRSIZ()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   returns the screen size in rows and columns. 
 
 Example: 
   
   RXSCRSIZ()            -> "25 80"
   
   
 
 Note: 
   
   The returned value differs from system to system.  



RXSETPOS
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXSETPOS(row,col)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>< ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   sets the cursor position to the specified row and column.  If this is 
   successful, a null string is returned. For example, for a 25x80 
   display, a row can be 0 to 24 and a column can be 0 to 79. 
 
 Examples: 
   
   RXSETPOS(9,1)
   RXSETPOS(0,0)
   
    



RXSLEEP
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXSLEEP(delay)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ><  ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   delays for the specified number (delay) of seconds. 
 
 Examples: 
   
   RXSLEEP(5)
   RXSLEEP(14)
   
    



RXWRSCR
 Syntax 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³                                                                      ³
   ³ >>ÄÄRXWRSCR(stringÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄ>< ³
   ³                     ÀÄ,text attributeÄÙ ÀÄ,scroll attributeÄÙ        ³
   ³                                                                      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   
   writes the specified string to the screen starting at the current 
   cursor position. 
 
 Notes: 
   
   o If a text attribute is specified, the string will be written to the 
     screen using the specified attribute.  If no attribute is 
     specified, the string is written to the screen using attribute 7 
     (white text on a black background). 
   o If a scroll attribute is specified, the screen will be scrolled, as 
     necessary, so that the entire string can be written to the screen. 
     If the screen is scrolled, any new lines created will have the 
     specified scroll attribute.  If no scroll attribute is specified, 
     the screen will not be scrolled. 
   o RXWRSCR returns the number of characters that it was not able to 
     write to the screen.  If a scroll attribute is specified, the 
     string will always be completely written to the screen, and the 
     function will always return 0.  If no scroll attribute is 
     specified, the screen will not be scrolled, and RXWRSCR might 
     return a value greater than 0, depending upon whether it can write 
     the entire string to the screen. 
   o The output of RXWRSCR cannot be redirected. 
   o RXWRSCR ignores any text or screen colors established using 
     ANSI.SYS. 
   o RXWRSCR recognizes and implements the following ANSI control 
     characters if they appear in string:  bell, backspace, carriage 
     return, and line feed.  The implementation of backspace is 
     non-destructive.  For example, the cursor is moved back one 
     position without deleting any character that might already exist at 
     that position. 
   o RXWRSCR automatically advances the cursor after each character is 
     written to the screen.  If the cursor is in the last column of the 
     last row on the screen and scrolling is disabled, the cursor will 
     not advance. 
   o RXWRSCR supports the following video attributes: 
   
 
 Foreground Colors: 
 
 
  0  black     4  red         8 gray         12 light red
 
  1  blue      5  magenta     9 light blue   13 light magenta
 
  2  green     6  brown      10 light green  14 yellow
 
  3  cyan      7  white      11 light cyan   15 high intensity white
 
 
 Background Colors: 
 
 
   0 black     32 green      64 red           96 brown
 
  16 blue      48 cyan       80 magenta      112 white
 
 
 Examples: 
 
 If the screen is in an 80 column by 25 line text mode: 
 
    RXSETPOS(10,10)
    RXWRSCR('Hello World',30)
 
 writes "Hello World" in yellow (14) on a blue (16) background, starting at 
 column 10 of row 10.  Also, RXWRSCR returns 0 because it was able to write 
 the entire string to the screen. 
 
 If the screen is in an 80 column by 25 line text mode: 
 
    RXSETPOS(24,75)
    RXWRSCR('Hello World',30)
 
 writes "Hello " in yellow (14) on a blue (16) background, starting at 
 column 75 of row 24.  Because the string does not fit in the space 
 remaining on the screen, only "Hello " is written, and RXWRSCR returns 5. 
 
 If the screen is in an 80 column by 25 line text mode: 
 
    RXSETPOS(24,75)
    RXWRSCR('Hello World',30,7)
 
 writes "Hello World" in yellow (14) on a blue (16) background starting at 
 column 75 of row 24.  Because the string does not fit in the space 
 remaining, the screen is scrolled.  The remaining text is written on the 
 new line that was created when the screen was scrolled. 



PC DOS Error Codes
 
 
 The following is a list of the PC DOS error codes that can be returned 
 after executing a REXX external function. 
 
 Decimal Code   Meaning 
 2              File not found 
 3              Path not found 
 5              Access denied 
 10             Invalid environment 
 15             Invalid drive was specified 
 16             Attempt to remove the current directory 
 19             Attempt to write on write-protected diskette 
 21             Drive not ready 
 29             Write fault 
 30             Read fault 
 32             Sharing violation 
 



Writing REXX External Functions
 
 
 External functions can be written in either REXX or a compiled language, 
 such as C or Assembler.  An external function is called the same way as a 
 built-in function is called.  External functions can return their result 
 string in a 256-byte result buffer. 
 
 Double-click on one of the following for more information: 
   
   o External Functions Written in the REXX Language 
   o External Functions Written in a Compiled Language 
   o REXX Variable Pool Interface 
   o C Language Example 
   o REXX Language Example 
   



External Functions Written in the REXX Language
 
 
 REXX language external functions must have a file name extension of .BAT. 
 These functions receive arguments from the argument strings provided to the 
 function, and they return their result string using the RETURN instruction. 



External Functions Written in a Compiled Language
 
 
 External functions written in a compiled language exist in a standard PC 
 DOS .COM or .EXE format; however, these functions must have a file name 
 extension of .RX.  These functions receive arguments, and they return their 
 result based on information passed from the external function's Program 
 Segment Prefix (PSP). 
 
 Information placed in the PSP of the external function by the REXX 
 interpreter includes: 
   
   PSP:0054h   4-byte character string REXX indicating that 
               the REXX interpreter is active 
   PSP:0058h   4-byte far pointer to the variable pool 
               interface entry point (SHVENTRY) 
   PSP:0082h   2-byte argument count (RXARGC) 
   PSP:0084h   4-byte far pointer to the argument array 
               (RXARGV) 
   PSP:0088h   4-byte far pointer to the result string buffer 
               (RXRESULT) 
   
   
   Argument processing uses the RXARGC and RXARGV information.  RXARGC 
   indicates the number of arguments passed to the external function. 
   RXARGV is a far pointer to RXARGC occurrences of a 6-byte structure. 
   The 6-byte structure consists of a 2-byte string length and a 4-byte 
   far pointer that points to the actual argument. 
   
   The following example shows argument processing of an external function 
   call with three arguments; "1414", "Test string argument", and "69". 
   
   Example: 
   
   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³PSP:0054h - "REXX"  ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
   ³PSP:0058h - SHVENTRY³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
   ³        . . .       ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
   ³PSP:0082h - RXARGC=3³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
   ³PSP:0084h - RXARGV  ÃÄÄÄ¿
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ³
   ³PSP:0088h - RXRESULT³   ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ³2-byte³4-byte ³³2-byte³4-byte ³³2-byte³4-byte ³
                            ³length³pointer³³length³pointer³³length³pointer³
                            ÀÄÄÄÄÄÄÁÄÄÄÂÄÄÄÙÀÄÄÄÄÄÄÁÄÄÄÂÄÄÄÙÀÄÄÄÄÄÄÁÄÄÂÄÄÄÄÙ
        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ               ³              ³
        ³                                              ³              ³
        ³                      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ              ³
        ³                      ³                                      ³
        ÃÄÄÄÄÄÄ¿               ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿               ÃÄÄÄÄ¿
        ³"1414"³               ³"Test string argument"³               ³"69"³
        ÀÄÄÄÄÄÄÙ               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ               ÀÄÄÄÄÙ
   
   If the external function returns a result, the result string is placed 
   in RXRESULT prior to terminating. 
   
   If the external function sets a non-zero return code at exit, the REXX 
   interpreter generates Error 40, Incorrect call to routine. 



REXX Variable Pool Interface
 
 
 The REXX variable pool interface allows an external function to directly 
 access the variables of a REXX procedure.  A far pointer to a shared 
 variable block (SHVBLOCK) must be passed as an argument when calling the 
 variable pool interface entry point.  All processor registers, except AX, 
 are preserved across the call.  



C Language Example
 
 
 The following example is a sample of code written in the C programming 
 language. It demonstrates how to write an external function that receives 
 arguments, uses the variable pool interface, and returns a result string. 
 The sample code uses RXARGC and the RXARGV-argument array to process 
 arguments, SHVBLOCK to access the variables of a REXX procedure, and the 
 RXRESULT pointer to return a result string. 
 
 /*****  REXXVAR.C  -  Access the variables of an active REXX procedure  ******/
 
 #include <string.h>                        /* Needed Header files            */
 #include <stdio.h>
 #include <dos.h>
 #include <stdlib.h>
 
 #define RXSHV_SET       0x00               /* Set var from given value       */
 #define RXSHV_FETCH     0x01               /* Copy value of var to buffer    */
 #define RXSHV_DROPV     0x02               /* Drop variable                  */
 #define RXSHV_SYSET     0x03               /* Symbolic name Set variable     */
 #define RXSHV_SYFET     0x04               /* Symbolic name Fetch variable   */
 #define RXSHV_SYDRO     0x05               /* Symbolic name Drop variable    */
 #define RXSHV_NEXTV     0x06               /* Fetch "next" variable          */
 #define RXSHV_PRIV      0x07               /* Fetch private information      */
 #define RXSHV_EXIT      0x08               /* Set function exit value        */
 
 #define RXSHV_OK        0x00               /* Execution was OK               */
 #define RXSHV_NEWV      0x01               /* Variable did not exist         */
 #define RXSHV_LVAR      0x02               /* Last var trans via SHVNEXTV    */
 #define RXSHV_TRUNC     0x04               /* Truncation occurred-Fetch      */
 #define RXSHV_BADN      0x08               /* Invalid variable name          */
 #define RXSHV_MEMFL     0x10               /* Out of memory failure          */
 #define RXSHV_BADF      0x80               /* Invalid funct code (shvcode)   */
 
 struct RXSTR                               /******  REXX String Format  ******/
 {
   unsigned int  StrLen;                    /* Length of string               */
   char far *    StrPtr;                    /* Pointer to string              */
 };
 
 struct SHVBLOCK                            /****  Shared Variable Block  *****/
 {
   struct SHVBLOCK far * ShvNext;           /* Point to next block or NULL    */
   struct RXSTR          ShvNam;            /* Variable name                  */
   struct RXSTR          ShvVal;            /* Variable value                 */
   unsigned int          ShvNamL;           /* Returned variable name length  */
   unsigned int          ShvValL;           /* Returned variable value length */
   unsigned char         ShvCode;           /* Function code                  */
   unsigned char         ShvRet;            /* Return code from call          */
 };
 
 struct ARGBUF                              /***  Information passed in PSP  **/
 {
   char               Rexx[4];              /* Points to "REXX" string in PSP */
   void far *         ShvEntry;             /* Entry point to REXX interface  */
   char               Filler[38];           /* Unused area in PSP             */
   unsigned int       RXargc;               /* Argument count                 */
   struct RXSTR far * RXargv;               /* Ptr to RXSTR argument array    */
   char far *         RXresult;             /* Ptr to 256-byte result buffer  */
 };
 
 void (far *RXcall)(void far *);          /* Function pointer to REXX         */
 char  ValBuf[200];                       /* Returned var value from REXX     */
 struct ARGBUF far * myPSP;               /* Pointer to extract values in PSP */
 struct SHVBLOCK Shv = {0,{0,0},{200,0},0,0,0,0};  /* Init SHVBLOCK struct    */
 
 void main( void )
 {
    FP_SEG( myPSP ) = _psp;     /* Initialize to Program Segment Prefix (PSP) */
    FP_OFF( myPSP ) = 0x54;     /* Offset 0x54                                */
 
    if(_fstrncmp( (char far *)myPSP, (char far *)"REXX", 4 ) != 0)
       exit( 0xff );           /* Called from REXX?  If not, exit with error. */
 
    (void far *)RXcall = myPSP->ShvEntry; /* Initialize to REXX's entry point */
 
    switch( toupper( *myPSP->RXargv[0].StrPtr ) )  /* Get function to execute */
    {
     case 'S' :                                    /* Was SET specified?      */
       Shv.ShvCode       = RXSHV_SYSET;            /* Set variable function   */
       Shv.ShvNam.StrLen = myPSP->RXargv[1].StrLen;/* Get length of var name  */
       Shv.ShvNam.StrPtr = myPSP->RXargv[1].StrPtr;/* Get pointer to var name */
       Shv.ShvVal.StrLen = myPSP->RXargv[2].StrLen;/* Get length of value     */
       Shv.ShvVal.StrPtr = myPSP->RXargv[2].StrPtr;/* Get pointer to value    */
       (RXcall)(  );                           /* Call REXX               */
       break;
 
     case 'G' :                                    /* Was GET specified?      */
       Shv.ShvCode       = RXSHV_SYFET;            /* Set variable function   */
       Shv.ShvNam.StrLen = myPSP->RXargv[1].StrLen;/* Get length of var name  */
       Shv.ShvNam.StrPtr = myPSP->RXargv[1].StrPtr;/* Get pointer to var name */
       Shv.ShvVal.StrPtr = (char far *)ValBuf;     /* Get ptr to Value buffer */
       (RXcall)(  );                           /* Call REXX               */
       if( Shv.ShvRet != RXSHV_OK )    /* Error?,  exit with that return code */
         return;
       printf("\n%s\n", ValBuf);         /* If value came back OK, display it */
       break;
 
     case 'D' :                                    /* Was DROP specified?     */
       Shv.ShvCode       = RXSHV_SYDRO;            /* Set variable function   */
       Shv.ShvNam.StrLen = myPSP->RXargv[1].StrLen;/* Get length of var name  */
       Shv.ShvNam.StrPtr = myPSP->RXargv[1].StrPtr;/* Get pointer to var name */
       (RXcall)(  );                           /* Call REXX               */
       break;
     default :
       exit( 0xff );                               /* Else, exit with error   */
    }
 
    /** Set Return value to either 1 or 0 based on the return code from REXX **/
    _fstrcpy(myPSP->RXresult,((Shv.ShvRet) ? (char far *)"1" : (char far *)"0"));
    exit( (int)Shv.ShvRet );                       /* Exit with return code   */
 }
 
 



REXX Language Example
 
 
 The following example is a sample of code written in the REXX programming 
 language. It calls the C Language external function listed above. 
 
 /********************************************************************/
 /*  REXXTEST.BAT - Sample REXX program to illustrate the use of the */
 /*                 Shared Variable Pool from an external function   */
 /*                 and the setting of the RESULT variable.          */
 /********************************************************************/
 
 MYREXXVAR = "This Is PC DOS 7 REXX"
 
 say
 say 'Current value is:  "'MYREXXVAR'".'
 say
 say "Now we'll SET it to a new value by calling REXXVAR.RX"
 say
 
 call REXXVAR "S","MYREXXVAR","A really cool programming language!"
 
 say "Result="Result
 
 say
 say 'New value is:  "'MYREXXVAR'".'
 say
 say "Now let's have REXXVAR.RX display its value by doing a GET"
 
 call REXXVAR "G","MYREXXVAR"
 
 say
 say "Result="Result
 say
 
 say "Now let's DROP its value by calling REXXVAR.RX"
 
 call REXXVAR "D","MYREXXVAR"
 
 say
 say "Result="Result
 
 say
 say 'Now the value is:  "'MYREXXVAR'".'
 say
 
 



Error Numbers and Messages
 
 
 The error numbers produced by syntax errors during processing of REXX 
 programs are all in the range 3 to 49 (and this is the value placed in the 
 variable RC when SIGNAL ON SYNTAX event is trapped). 
 
 The external interfaces to the language processor can generate two of the 
 error messages either before the language processor gains control or after 
 control has left the language processor. Therefore, SIGNAL ON SYNTAX cannot 
 trap these errors. The error numbers involved are 3 and 5 (if the initial 
 requirements for storage could not be met). Similarly, only SIGNAL ON HALT 
 or CALL ON HALT can trap error 4. 
 
 Two of the error messages are generated when the program is being 
 tokenized. Because the program has not yet started executing, SIGNAL ON 
 SYNTAX cannot trap these errors unless they occur during execution of an 
 INTERPRET instruction. The errors involved are 6 and 30. 
   
   
   Error 3   Program is unreadable 
             
             Explanation: The REXX program could not be read 
             from the disk. 
   
   Error 4   Program interrupted 
             
             Explanation: The system interrupted execution of 
             your REXX program. This is because of some error or 
             user request. Unless CALL on HALT or SIGNAL ON HALT 
             is in effect, the language processor immediately 
             ceases processing with this message. 
   
   Error 5   Machine resources exhausted 
             
             Explanation: While trying to process a program, the 
             language processor was unable to get the resources 
             it needed to continue. (For example, it could not 
             get the space needed for its work areas, variables, 
             and so on.) The program that called the language 
             processor may itself have already used up most of 
             the available storage. Or a request for storage may 
             have been for more than the implementation maximum. 
   
   Error 6   Unmatched "/*" or quote 
             
             Explanation: A comment or literal string was 
             started but never finished. This could be because 
             the language processor detected: 
             
             - The end of the program (or the end of the string 
             in an INTERPRET instruction) without finding the 
             ending "*/" for a comment or the ending quotation 
             mark for a literal string 
             - The end of the line for a literal string. 
   
   Error 7   WHEN or OTHERWISE expected 
             
             Explanation: The language processor expects at 
             least one WHEN construct (and possibly an OTHERWISE 
             clause) within a SELECT statement. The language 
             processor issues this message when it finds any 
             other instruction or there is no WHEN construct 
             before the OTHERWISE or all WHEN expressions are 
             false and an OTHERWISE is not present. A common 
             cause of this error is forgetting the DO and END 
             instructions around the list of instructions 
             following a WHEN. For example: 
             
                 WRONG                  RIGHT
             
             Select                 Select
               When a=c then          When a=c then DO
                 Say 'A equals C'       Say 'A equals C'
                 exit                   exit
               Otherwise nop            end
               end                    Otherwise nop
                                      end
             
             
   
   Error 8   Unexpected THEN or ELSE 
             
             Explanation: The language processor has found a 
             THEN or an ELSE clause that does not match a 
             corresponding IF or WHEN clause. This often occurs 
             because of a missing END or DO...END in the THEN 
             part of a complex IF...THEN...ELSE construction. 
             For example: 
             
                WRONG                     RIGHT
             
             If a=c then do;           If a=c then do;
               Say EQUALS                Say EQUALS
               exit                      exit
              else                       end
               Say NOT EQUALS           else
                                         Say NOT EQUALS
             
             
   
   Error 9   Unexpected WHEN or OTHERWISE 
             
             Explanation: The language processor has found a 
             WHEN or OTHERWISE outside of a SELECT construction. 
             You may have accidentally enclosed the instruction 
             in a DO...END construction by leaving off an END 
             instruction, or you may have tried to branch to it 
             with a SIGNAL statement (which cannot work because 
             the SELECT is then terminated). 
   
   Error 10  Unexpected or unmatched END 
             
             Explanation: The language processor has found more 
             END instructions in your program than DO or SELECT 
             instructions, or the END instructions were placed 
             so that they did not match the DO or SELECT 
             instructions. 
             
             This message can occur if you try to transfer 
             control into the middle of a loop using SIGNAL. In 
             this case, REXX does not expect the END instruction 
             because it did not process the previous DO 
             instruction. Remember also, that SIGNAL deactivates 
             any current loops, so it cannot transfer control 
             from one place inside a loop to another. 
             
             Another cause for this message is placing an END 
             immediately after a THEN or ELSE subkeyword or 
             specifying a name on the END keyword that does not 
             match the name following DO. It may be helpful to 
             use TRACE Scan to show the structure of the program 
             and to make the location of the error more obvious. 
             Putting the name of the control variable on END 
             instructions that close repetitive loops can also 
             help locate this kind of error. 
   
   Error 11  Control stack full 
             
             Explanation: The language processor issues this 
             message if your program exceeds the limit on levels 
             of nesting of control structures (DO...END, 
             IF...THEN...ELSE, and so on). 
             
             This could be because of a looping INTERPRET 
             instruction, such as: 
             
             line='INTERPRET line'
             INTERPRET line
             
             These lines would loop until they exceeded the 
             nesting level limit and the language processor 
             issues this message. Similarly, a recursive 
             subroutine that does not terminate correctly could 
             loop until it causes this message. 
   
   Error 13  Invalid character in program 
             
             Explanation: The language processor found a 
             character outside of a literal (quoted) string that 
             is not a blank or one of the following: 
             
             (Alphamerics)
             A through Z, a through z, 0 through 9
             
             (Name Characters)
             ! _ ? .
             
             (Special Characters)
             & * ( ) - + = ª ' " ; : < , > / \ | %
             
             
   
   Error 14  Incomplete DO/SELECT/IF 
             
             Explanation: The language processor has reached the 
             end of the program (or end of the string for an 
             INTERPRET instruction) and has found a DO or SELECT 
             instruction without a matching END instruction, or 
             an IF clause that a THEN clause does not follow. 
             Putting the name of the control variable on each 
             END closing a controlled loop can help locate this 
             kind of error. 
   
   Error 15  Invalid hexadecimal or binary string 
             
             Explanation: For the language processor, 
             hexadecimal strings cannot have leading or trailing 
             blanks and can have imbedded blanks only at byte 
             boundaries. Only the digits 0-9 and the letters a-f 
             and A-F are allowed. The following are all valid 
             hexadecimal strings: 
             
             '13'x
             'A3C2 1c34'x
             '1de8'x
             
             Binary strings can have blanks only at the 
             boundaries of groups of four binary digits. Only 
             the digits 0 and 1 are allowed. These are all valid 
             binary strings: 
             
             '1011'b
             '110 1101'b
             '101101 11010011'b
             
             You may have mistyped one of the digits, for 
             example, typing a letter o instead of 0. Or you may 
             have put the 1-character symbol X or B (the name of 
             the variable X or B respectively) after a literal 
             string when the string is not intended as a 
             hexadecimal or binary specification. In this case, 
             use the explicit concatenation operator (||) to 
             concatenate the string to the value of the symbol. 
   
   Error 16  Label not found 
             
             Explanation: A SIGNAL instruction has been executed 
             (or an event for which a trap was set with SIGNAL 
             ON has occurred), and the language processor could 
             not find the label specified. You may have mistyped 
             the label or forgotten to include it. 
   
   Error 17  Unexpected PROCEDURE 
             
             Explanation: The language processor encountered a 
             PROCEDURE instruction in an incorrect position.  
             This could occur because no internal routines are 
             active or because the PROCEDURE instruction was not 
             the first instruction processed after the CALL 
             instruction or function call. One cause for this 
             error is dropping through to an internal routine, 
             rather than calling it with a CALL instruction or a 
             function call. 
   
   Error 18  THEN expected 
             
             Explanation: A THEN clause must follow each REXX IF 
             or WHEN clause. The language processor found 
             another clause before it found a THEN clause. 
   
   Error 19  String or symbol expected 
             
             Explanation: The language processor expected a 
             symbol or string following the CALL or SIGNAL 
             keywords but found none. You may have omitted the 
             string or symbol, or you may have inserted a 
             special character (such as a parenthesis). 
   
   Error 20  Symbol expected 
             
             Explanation: The language processor expects a 
             symbol after CALL ON, CALL OFF, END, ITERATE, 
             LEAVE, NUMERIC, PARSE, SIGNAL ON, or SIGNAL OFF 
             keywords. It expects a list of symbols or variable 
             references after DROP and PROCEDURE EXPOSE. Either 
             there was no symbol when one was required or the 
             language processor found some other token. 
   
   Error 21  Invalid data on end of clause 
             
             Explanation: Some token other than a comment 
             follows a clause, such as SELECT or NOP. 
   
   Error 22  Invalid character string 
             
             Explanation: This error results if a literal string 
             contains character codes that are not valid. This 
             might be because some characters are impossible, or 
             because the character set is extended in some way 
             and certain character combinations are not allowed. 
   
   Error 23  Invalid data string 
             
             Explanation: A data string (that is, the result of 
             an expression) contains character codes that are 
             not valid. This might be because some characters 
             are impossible or because the character set is 
             extended in some way and a given character 
             combination is not allowed. 
   
   Error 24  Invalid TRACE request 
             
             Explanation: The language processor issues this 
             message when: 
             
             - The option specified on a TRACE instruction or 
             the argument to the built-in function, did not 
             start with an A, C, E, F, I, L, N, O, or R. 
             - In interactive debug, if you enter a number that 
             is not a whole number. 
   
   Error 25  Invalid subkeyword found 
             
             Explanation: The language processor expected a 
             particular subkeyword at this position in an 
             instruction but found something else. For example, 
             in the NUMERIC instruction the second token must be 
             the subkeyword DIGITS, FORM, or FUZZ. If anything 
             else follows NUMERIC, this message is issued. 
   
   Error 26  Invalid whole number 
             
             Explanation: The language processor found an 
             expression that did not evaluate to a whole number 
             or is greater than the limit (for these uses: 999 
             999 999). This could be in one of the following: 
             
             - Positional patterns in parsing templates 
             (including variable positional patterns) 
             - The operand to the right of the power (**) 
             operator 
             - The values of exprr and exprf in the DO 
             instruction 
             - The values given for DIGITS or FUZZ in the 
             NUMERIC instruction 
             - Any number used in the option in the TRACE 
             instruction. 
             
             This error is also raised if the value is not 
             permitted (for example, a negative repetition count 
             in a DO instruction), or when the division 
             performed during an integer divide or remainder 
             operation does not result in a whole number. 
   
   Error 27  Invalid DO syntax 
             
             Explanation: The language processor found a syntax 
             error in the DO instruction. You might have used 
             BY, TO, FOR, WHILE, or UNTIL twice or used a WHILE 
             and an UNTIL. 
   
   Error 28  Invalid LEAVE or ITERATE 
             
             Explanation: The language processor encountered a 
             LEAVE or ITERATE instruction in an incorrect 
             position because: 
             
             - No loop was active, or 
             - The name specified on the instruction did not 
             match the control variable of any active loop. Note 
             that internal routine calls and the INTERPRET 
             instruction protect DO loops by making them 
             inactive. Therefore, for example, a LEAVE 
             instruction in a subroutine cannot affect a DO loop 
             in the calling routine. 
             
             One cause for this message is trying to use the 
             SIGNAL instruction to transfer control within or 
             into a loop. Because a SIGNAL instruction 
             terminates all active loops, any ITERATE or LEAVE 
             instruction would cause this message. 
   
   Error 29  Environment name too long 
             
             Explanation: The language processor encountered an 
             environment name on an ADDRESS instruction that is 
             longer than the limit of 250 characters. 
   
   Error 30  Name or string too long 
             
             Explanation: The language processor found a 
             variable name or label name or literal (quoted) 
             string that is longer the allowed limit of 250 
             characters. 
             
             The limit for names includes any substitutions. A 
             possible cause of this error is using a period (.) 
             in a name, causing an unexpected substitution. 
             
             Leaving off an ending quotation mark for a literal 
             string (or putting a single quotation mark in a 
             string) can cause this error because several 
             clauses may be included in the string. For example, 
             write the string 'don't' as 'don''t' or "don't". 
   
   Error 31  Name starts with numeric or "." 
             
             Explanation: The language processor found a 
             variable whose name began with a digit or a period. 
             The REXX rules do not allow you to assign a value 
             to a variable whose name begins with a digit or a 
             period, because you could then redefine numeric 
             constants. 
   
   Error 33  Invalid expression result 
             
             Explanation: The language processor encountered an 
             expression result that is incorrect in its 
             particular context. The result of an expression 
             might be incorrect in one of the following: 
             
             ADDRESS VALUE expression
             NUMERIC DIGITS expression
             NUMERIC FORM VALUE expression
             NUMERIC FUZZ expression
             OPTIONS expression
             SIGNAL VALUE expression
             TRACE VALUE expression
             
             (FUZZ must be smaller than DIGITS.)
             
             
   
   Error 34  Logical value not 0 or 1 
             
             Explanation: The language processor found an 
             expression in an IF, WHEN, DO WHILE, or DO UNTIL 
             phrase that did not result in a 0 or 1. Any value 
             operated on by a logical operator (ª, |, &, or &&) 
             must result in a 0 or 1. For example, the phrase 
             
             If result then exit rc
             
             fails if result has a value other than 0 or 1. 
             Thus, it would be better to write the phrase: 
             
             If resultª=0 then exit rc
             
             
   
   Error 35  Invalid expression 
             
             Explanation: The language processor found a 
             grammatical error in an expression. This could be 
             because: 
             
             - You ended an expression with an operator 
             - You specified, in an expression, two operators 
             next to one another with nothing in between them 
             - You did not specify a right parenthesis when one 
             was required 
             - You used special characters (such as operators) 
             in an intended character expression without 
             enclosing them in quotation marks. For example, in 
             PC DOS, you should write the command 
             
             DIR C:\UTIL\*.*
             
             as follows: 
             
             DIR 'C:\UTIL\*.*'
             
             (assuming DIR is not a variable) or even as 
             
             'DIR C:\UTIL\*.*'
             
             
   
   Error 36  Unmatched "(" in expression 
             
             Explanation: The language processor found an 
             unmatched parenthesis within an expression. There 
             are more left parentheses than right parentheses. 
             To include a single parenthesis in a command, 
             enclose it in quotation marks. 
   
   Error 37  Unexpected "," or ")" 
             
             Explanation: The language processor found a comma 
             (,) outside a routine invocation or too many right 
             parentheses in an expression. You get this message 
             if you include a comma in a character expression 
             without enclosing it in quotation mark. For 
             example, write the instruction: 
             
             Say Enter A, B, or C
             
             as follows: 
             
             Say 'Enter A, B, or C'
             
             
   
   Error 38  Invalid template or pattern 
             
             Explanation: In a parsing template, the language 
             processor found a special character that is not 
             allowed, for example, .%, or the syntax of a 
             variable trigger was incorrect (no symbol was found 
             after a left parenthesis). This message is also 
             issued if you omit the WITH subkeyword in a PARSE 
             VALUE instruction. 
   
   Error 39  Evaluation stack overflow 
             
             Explanation: The language processor was not able to 
             evaluate the expression because it is too complex. 
             There are too many nested parentheses, functions, 
             and so on). 
   
   Error 40  Incorrect call to routine 
             
             Explanation: The language processor encountered an 
             incorrect call to routine. Some possible causes 
             are: 
             
             - You passed incorrect data (arguments) to the 
             built-in or external routine. 
             - You passed too many arguments to the built-in, 
             external, or internal routine. 
             - The external routine called was not compatible 
             with the language processor. 
             
             If you were not trying to call a routine, you may 
             have a symbol or a string adjacent to a "(" when 
             you meant it to be separated by a space or an 
             operator. The language processor would see this as 
             a function call. For example, write TIME(4+5) as 
             follows: TIME*(4+5). 
   
   Error 41  Bad arithmetic conversion 
             
             Explanation: The language processor found a term in 
             an arithmetic expression that was not a valid 
             number or that had an exponent outside the allowed 
             range of -999 999 999 to +999 999 999. 
             
             You may have mistyped a variable name, or included 
             an arithmetic operator in a character expression 
             without putting it in quotation marks. For example, 
             write the command DIR *prod.dat as 'DIR *prod.dat' 
             (in quotation marks). Otherwise, the language 
             processor tries to multiply DIR by 
             prod.dat. 
   
   Error 42  Arithmetic overflow/underflow 
             
             Explanation: The language processor encountered the 
             result of an arithmetic operation that required an 
             exponent greater than the limit of nine digits 
             (more than 999 999 999 or less than -999 999 999). 
             
             This error can occur during evaluation of an 
             expression (often as a result of trying to divide a 
             number by 0) or while stepping a DO loop control 
             variable. 
   
   Error 43  Routine not found 
             
             Explanation: The language processor was unable to 
             find a routine called in your program. You called a 
             function within an expression or called a 
             subroutine with CALL, but: 
             
             - The specified label is not in the program, or 
             - It is not the name of a built-in function, or 
             - The language processor could not locate it 
             externally. 
             
             The simplest, and probably most common, cause of 
             this error is mistyping the name. 
             
             If you were not trying to call a routine, you may 
             have put a symbol or string adjacent to a (when you 
             meant it to be separated by a space or an 
             operator). The language processor would see that as 
             a function call. For example, write the string 
             3(4+5) as 3*(4+5). 
   
   Error 44  Function did not return data 
             
             Explanation: The language processor called an 
             external routine within an expression. The routine 
             seemed to end without error, but it did not return 
             data for use in the expression. 
             
             This may be because of specifying the name of a 
             program that is not intended for use as a REXX 
             function. Call it as a command or subroutine 
             instead. 
   
   Error 45  No data specified on function RETURN 
             
             Explanation: A REXX program has been called as a 
             function, but an attempt is being made to return 
             (by a RETURN instruction) without passing back any 
             data. Similarly, an internal routine, called as a 
             function, must end with a RETURN statement 
             specifying an expression. 
   
   Error 46  Invalid variable reference 
             
             Explanation: Within an ARG, DROP, PARSE, PULL, or 
             PROCEDURE instruction, the syntax of a variable 
             reference (a variable whose value is to be used, 
             indicated by its name being enclosed in 
             parentheses) is incorrect. The right parenthesis 
             that should immediately follow the variable name 
             may be missing or the variable name may be 
             misspelled. 
   
   Error 47  Unexpected label 
             
             Explanation: The language processor found a label, 
             being used incorrectly, in the expression being 
             evaluated  for an INTERPRET instruction or in an 
             expression entered during interactive debug. Do not 
             use a label in these expressions. 
   
   Error 48  Failure in system service 
             
             Explanation: The language processor halts execution 
             of the program because some system service, such as 
             stream input or output or the manipulation of the 
             external data queue, has failed to work correctly. 
   
   Error 49  Interpretation error 
             
             Explanation: The language processor has encountered 
             a severe error while performing a self-consistency 
             check. 
   



Some REXX Examples
 
 
 This section provides examples that demonstrate some basic ways to use a 
 REXX program.  The following programs are described: 
   
   o Determining the success or failure of the PC DOS COPY command. 
   o Using the RXFINFO external function (utility). 
   o Demonstrating ANSI.SYS capabilities using a REXX program. 
   
 
 Example 1: 
 
 Internal PC DOS commands do not return any return codes (RCs). This example 
 is used to determine the success or failure of the internal PC DOS COPY 
 command. 
 
 The method used in this example is: 
 
 o Redirect the output from the COPY command into the file 
   RESULT.DOS. 
 o Execute the internal function FilesCopied, which reads the contents of 
   RESULT.DOC into the variable line.  line will be in the format n files 
   copied. 
 o Use the PARSE instruction to separate n (number of files copied) from 
   file(s) copied. 
 o SAY the number of files copied. 
 
 
 /*------------------------------------------------------------------*/
 /*  EXAMPLE1.BAT                                                    */
 /*------------------------------------------------------------------*/
 'COPY C:\AUTOEXEC.BAT C:\A.BAK > RESULT.DOS'  /* In this example    */
 copyRC = FilesCopied('RESULT.DOS')            /* we expect 1 file   */
 say copyRC 'file(s) copied'                   /* to be copied       */
 
 call STREAM 'RESULT.DOS','COMMAND','CLOSE'    /* Close the file     */
 
 'COPY C:\AUTOEXEC.BAD C:\A.BAK >RESULT.DOS'   /* In this example    */
 copyRC = FilesCopied('RESULT.DOS')            /* we expect 0 files  */
 say copyRC 'file(s) copied'                   /* to be copied       */
 
 call STREAM 'RESULT.DOS','COMMAND','CLOSE'    /* Close the file     */
 
 'COPY C:\DOS\*.RX C:\BACKUP >RESULT.DOS'      /* In this example    */
 copyRC = FilesCopied('RESULT.DOS')            /* we expect multiple */
 say copyRC 'file(s) copied'                   /* files to be copied */
 
 call STREAM 'RESULT.DOS','COMMAND','CLOSE'    /* Close the file     */
 
 exit                                          /* Exit program       */
 
 /*------------------------------------------------------------------*/
 /*  FilesCopied: Returns the number of files copied.                */
 /*------------------------------------------------------------------*/
 FilesCopied:
 parse arg file                                /* Parse the argument */
 
 do while LINES(file)                          /* Read all lines     */
    line = LINEIN(file)                        /* and keep only the  */
 end                                           /* last line          */
 
 parse var line n 'file(s)' test               /* Parse n and test   */
 n = STRIP(n)                                  /* Strip the spaces   */
 if (test = 'copied' & n > 0) then do          /* Everything ok?     */
    say "The copy was successful..."
    return n                                   /* Return success     */
 end
 else do                                       /* We had an error    */
    say "Copy Error!"
    return 0                                   /* Return error       */
 end
 
 return
 
 
 
 Example 2: 
 
 The following is an example of how you can use the RXFINFO external 
 function (utility) to generate a directory listing similar to the one 
 generated by the internal PC DOS DIR command. 
 
 The method used in this example is: 
 
 o Call RXFINFO with the parameter *.BAT. This will return the first file 
   that matches *.BAT. 
 o Call RXFINFO without parameters until no matches are found and it 
   returns nothing ('').  After each call to RXFINFO, file information is 
   displayed by the SAY instruction. 
 
 
 /*------------------------------------------------------------------*/
 /*  EXAMPLE2.BAT                                                    */
 /*------------------------------------------------------------------*/
 call RXFINFO '*.BAT'              /* With parameters - find first   */
 do while result <> ''
    say result
    call RXFINFO                   /* Without parameters - find next */
 end
 
 exit                              /* Exit program                   */
 
 
 
 Example 3: 
 
 The following example uses the PC DOS device driver ANSI.SYS escape 
 sequences within REXX.  ANSI.SYS escape sequences can be used to change 
 display graphics, control cursor movement, and reassign keys.  A complete 
 description of ANSI.SYS can be found in the online "PC DOS 7 Command 
 Reference." 
 
 Note: ANSI.SYS must be loaded for this example to function correctly. 
 
 The method used in this example is: 
 
 o Assign meaningful variable names to several of the ANSI.SYS escape 
   sequences. 
 o Use the SAY instruction to demonstrate some of the capabilities of 
   ANSI.SYS. 
 
 
 /*------------------------------------------------------------------*/
 /*  EXAMPLE3.BAT                                                    */
 /*------------------------------------------------------------------*/
 
 /*------------------------------------------------------------------*/
 /* Foreground colors:                                               */
 /*------------------------------------------------------------------*/
 Black       = '1b'x||'[30m';                      /* Black          */
 Red         = '1b'x||'[31m';                      /* Red            */
 Green       = '1b'x||'[32m';                      /* Green          */
 Yellow      = '1b'x||'[33m';                      /* Yellow         */
 Blue        = '1b'x||'[34m';                      /* Blue           */
 Magenta     = '1b'x||'[35m';                      /* Magenta        */
 Cyan        = '1b'x||'[36m';                      /* Cyan           */
 White       = '1b'x||'[37m';                      /* White          */
 BoldBlack   = '1b'x||'[1;30m'                     /* Bold Black     */
 BoldRed     = '1b'x||'[1;31m'                     /* Bold Red       */
 BoldGreen   = '1b'x||'[1;32m'                     /* Bold Green     */
 BoldYellow  = '1b'x||'[1;33m'                     /* Bold Yellow    */
 BoldBlue    = '1b'x||'[1;34m'                     /* Bold Blue      */
 BoldMagenta = '1b'x||'[1;35m'                     /* Bold Magenta   */
 BoldCyan    = '1b'x||'[1;36m'                     /* Bold Cyan      */
 BoldWhite   = '1b'x||'[1;37m'                     /* Bold White     */
 
 /*------------------------------------------------------------------*/
 /* Background colors:                                               */
 /*------------------------------------------------------------------*/
 BlackBack   = '1b'x||'[40m'                              /* Black   */
 RedBack     = '1b'x||'[41m'                              /* Red     */
 GreenBack   = '1b'x||'[42m'                              /* Green   */
 YellowBack  = '1b'x||'[43m'                              /* Yellow  */
 BlueBack    = '1b'x||'[44m'                              /* Blue    */
 MagentaBack = '1b'x||'[45m'                              /* Magenta */
 CyanBack    = '1b'x||'[46m'                              /* Cyan    */
 WhiteBack   = '1b'x||'[47m'                              /* White   */
 
 /*------------------------------------------------------------------*/
 /* Text Attributes:                                                 */
 /*------------------------------------------------------------------*/
 Normal      = '1b'x||'[0m'             /* All attributes off        */
 Bold        = '1b'x||'[1m'             /* Bold on (highlight)       */
 Underscore  = '1b'x||'[4m'             /* Underscore on             */
                                        /* (monochrome adaptor only) */
 Blink       = '1b'x||'[5m'             /* Blink on                  */
 Reverse     = '1b'x||'[7m'             /* Reverse video on          */
 Concealed   = '1b'x||'[8m'             /* Concealed on (invisible)  */
 
 /*------------------------------------------------------------------*/
 /* Sample Foreground "on" Background colors:                        */
 /*------------------------------------------------------------------*/
 WhiteOnBlue    = '1b'x||'[37;44m'              /* White on blue     */
 WhiteOnRed     = '1b'x||'[37;41m'              /* White on red      */
 RedOnBlack     = '1b'x||'[31;40m'              /* Red on black      */
 BoldRedOnBlack = '1b'x||'[1;31;40m'            /* Bold red on black */
 
 /*------------------------------------------------------------------*/
 /* Cursor Positioning:                                              */
 /*------------------------------------------------------------------*/
 CursorUp       = '1b'x||'[1A'     /* Cursor up 1 line               */
 CursorDown     = '1b'x||'[1B'     /* Cursor down 1 line             */
 CursorForward  = '1b'x||'[1C'     /* Cursor forward (right) 1 space */
 CursorBackward = '1b'x||'[1D'     /* Cursor backward (left) 1 space */
 ClearScreen    = '1b'x||'[2J'     /* Clear the screen and           */
                                   /* position cursor at 0,0         */
 EraseEOL       = '1b'x||'[K'      /* Erase to end of line           */
 
 /*------------------------------------------------------------------*/
 /* Demonstration begins here...                                     */
 /*                                                                  */
 /* Note: The following SAY statements contain colors enclosed in    */
 /*       parentheses, such as (black) and (bold cyan).  Items in    */
 /*       parentheses indicate that the previously specified         */
 /*       foreground or background attribute was not changed from    */
 /*       its previous setting.                                      */
 /*------------------------------------------------------------------*/
 say ClearScreen||"The screen has just been cleared"
 say
 say WhiteOnBlue||"White foreground on blue background"
 say
 say WhiteOnRed||"White foreground on red background"
 say
 say RedOnBlack||"Red foreground on black background"
 say
 say BoldRedOnBlack||"Bold red foreground on black background"
 say
 say Green||"Green foreground on (black) background"
 say
 say BoldCyan||"Bold cyan foreground on (black) background"
 say
 say BlueBack||"(Bold cyan) foreground on blue background"
 say
 say Blink||BoldRed||BlackBack||"Blinking bold red foreground on",
     "black background"
 say
 say Normal||"Restore to normal foreground and background"
 say
 
 exit                                              /* Exit program   */
 
 



Using the REXXDUMP Development Tool
 
 
 The REXXDUMP program displays all the variables and associated values of 
 the current REXX procedure. The REXX variable pool interface is used to 
 access these variables and values. 
 
 Because REXXDUMP is a program and not a REXX external function (utility), 
 the file name extension is .EXE rather than .RX as used by the utilities. 
 
 Example: 
   
   The following example demonstrates the usage of REXXDUMP: 
   
   /*-----------------------------------------------------------------*/
   /*  TESTDUMP.BAT - REXXDUMP example                                */
   /*-----------------------------------------------------------------*/
   one = 1
   two = 2
   sum = one + two
   
   say "==== Before executing REXXDUMP ===="
   "REXXDUMP"
   say "==== After  executing REXXDUMP ===="
   
   say
   say "one + two =" sum
   
   exit
   
   The example produces the following output: 
   
   ==== Before executing REXXDUMP ====
   Source info: DOS COMMAND C:\TESTDUMP.BAT
   SUM="3"
   TWO="2"
   ONE="1"
   ==== After  executing REXXDUMP ====
   
   one + two = 3
   
   




 When REXX finds a quotation mark (either " or '), it stops processing and 
 looks ahead for the matching quotation mark.  The string of characters 
 inside the matching quotation marks 
 is used as it is and is called a "literal string." 




 A stem is a symbol that contains only one period as the last character. 




 OS/2 is a trademark of IBM Corporation. 




 NetWare is a trademark of Novell, Inc. 



